---
title: "Agent Memory"
description: "Configure message history, semantic recall, and working memory for conversation continuity."
section: "agents"
order: 5
primaryKeyword: "AI agent memory"
relatedSlugs: ["agents/configuration", "agents/overview"]
pageType: "how-to"
---

# Agent Memory

Agent memory maintains conversation context across interactions, enabling multi-turn conversations, context-aware responses, and long-term relationship building. Memory is stored in PostgreSQL and persists across sessions, threads, and deployments.

## What memory does

Memory enables agents to:

- **Remember past messages** — Reference previous turns in the conversation
- **Maintain context** — Understand references to earlier topics ("What did I ask about earlier?")
- **Build relationships** — Remember user preferences, past interactions, and personal details
- **Improve relevance** — Use semantic search to find related messages from past conversations

Without memory, each agent turn is isolated — the agent has no context about previous messages, leading to repetitive or disconnected responses.

## Memory types

AgentC2 supports three memory mechanisms:

### 1. Message history (lastMessages)

Stores the last N messages in chronological order. Simple and fast, suitable for short-term context.

```json
{
    "memoryConfig": {
        "lastMessages": 20
    }
}
```

- **Fast retrieval** — Direct database lookup, no vector search
- **Chronological order** — Messages appear in conversation order
- **Token efficient** — Only includes recent messages
- **Use case**: Short conversations, immediate context

### 2. Semantic recall

Uses vector embeddings to find semantically similar messages from past conversations, even if they're not recent.

```json
{
    "memoryConfig": {
        "semanticRecall": {
            "topK": 5,
            "minScore": 0.7
        }
    }
}
```

- **Semantic search** — Finds related messages by meaning, not just recency
- **Cross-conversation** — Can reference messages from days or weeks ago
- **Configurable relevance** — `minScore` filters low-relevance results
- **Use case**: Long-term context, finding related past interactions

### 3. Working memory

Structured memory that persists key facts, preferences, and state across conversations.

```json
{
    "memoryConfig": {
        "workingMemory": {
            "enabled": true,
            "template": "User preferences: {{preferences}}. Recent topics: {{topics}}."
        }
    }
}
```

- **Structured storage** — Stores key-value pairs, not just messages
- **Template-based** — Injected into prompts via templates
- **Persistent state** — Survives conversation boundaries
- **Use case**: User profiles, preferences, session state

## Enabling memory

Enable memory by setting `memoryEnabled: true` and configuring `memoryConfig`:

```bash
curl -X POST https://agentc2.ai/agent/api/agents \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Memory-Enabled Agent",
    "instructions": "You are a helpful assistant with memory.",
    "modelProvider": "openai",
    "modelName": "gpt-4o",
    "memoryEnabled": true,
    "memoryConfig": {
      "lastMessages": 20,
      "semanticRecall": {
        "topK": 5,
        "minScore": 0.7
      }
    }
  }'
```

Or update an existing agent:

```bash
curl -X PATCH https://agentc2.ai/agent/api/agents/my-agent \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "memoryEnabled": true,
    "memoryConfig": {
      "lastMessages": 20,
      "semanticRecall": { "topK": 5 }
    }
  }'
```

## Memory configuration schema

The `memoryConfig` object supports:

| Field                         | Type            | Description                                         |
| ----------------------------- | --------------- | --------------------------------------------------- |
| `lastMessages`                | number          | Number of recent messages to include (0 = disabled) |
| `semanticRecall`              | object \| false | Semantic search config or `false` to disable        |
| `semanticRecall.topK`         | number          | Number of similar messages to retrieve              |
| `semanticRecall.minScore`     | number          | Minimum similarity score (0-1, default: 0.7)        |
| `semanticRecall.messageRange` | number          | Limit search to last N messages (optional)          |
| `workingMemory`               | object          | Working memory configuration                        |
| `workingMemory.enabled`       | boolean         | Enable working memory                               |
| `workingMemory.template`      | string          | Template string for injecting working memory        |

### Complete example

```json
{
    "memoryEnabled": true,
    "memoryConfig": {
        "lastMessages": 30,
        "semanticRecall": {
            "topK": 10,
            "minScore": 0.75,
            "messageRange": 1000
        },
        "workingMemory": {
            "enabled": true,
            "template": "User: {{userName}}. Preferences: {{preferences}}. Active projects: {{projects}}."
        }
    }
}
```

## Using threads

Memory is organized by **threads**. Each thread maintains its own conversation history, enabling multiple independent conversations with the same agent.

### Thread IDs

Specify a `threadId` in chat requests to maintain separate conversations:

```bash
# Conversation 1: Research thread
curl -X POST https://agentc2.ai/agent/api/agents/research-assistant/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      { "role": "user", "content": "Tell me about quantum computing" }
    ],
    "threadId": "research-thread-1"
  }'

# Conversation 2: Support thread (separate memory)
curl -X POST https://agentc2.ai/agent/api/agents/research-assistant/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      { "role": "user", "content": "I need help with my account" }
    ],
    "threadId": "support-thread-1"
  }'
```

Each thread maintains its own message history. The agent won't confuse topics between threads.

### Resource IDs

**Resource IDs** identify the user or entity that owns the thread. They're used for:

- **Multi-tenant isolation** — Each organization's memory is separate
- **User-specific context** — Memory is scoped to a user ID
- **Privacy** — Users can only access their own memory

Set the resource ID via `requestContext.userId`:

```bash
curl -X POST https://agentc2.ai/agent/api/agents/my-agent/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      { "role": "user", "content": "Hello" }
    ],
    "threadId": "user-123-conversation",
    "requestContext": {
      "userId": "user_123",
      "userName": "John Doe"
    }
  }'
```

If `requestContext.userId` is omitted, the platform uses `"test-user"` as the default resource ID.

## Memory in practice

### Example: Multi-turn conversation

```bash
# Turn 1
curl -X POST https://agentc2.ai/agent/api/agents/assistant/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      { "role": "user", "content": "My name is Alice and I love Python programming" }
    ],
    "threadId": "alice-thread"
  }'

# Turn 2 (agent remembers Alice's name and interest)
curl -X POST https://agentc2.ai/agent/api/agents/assistant/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      { "role": "user", "content": "What are some good Python libraries for data science?" }
    ],
    "threadId": "alice-thread"
  }'
```

The agent remembers Alice's name and interest in Python, providing personalized recommendations.

### Example: Semantic recall

With semantic recall enabled, the agent can find related messages from past conversations:

```bash
# Week 1: User asks about React
curl -X POST https://agentc2.ai/agent/api/agents/dev-assistant/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      { "role": "user", "content": "How do I use React hooks?" }
    ],
    "threadId": "dev-thread"
  }'

# Week 2: User asks about hooks again (semantic recall finds the previous message)
curl -X POST https://agentc2.ai/agent/api/agents/dev-assistant/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      { "role": "user", "content": "Remind me how hooks work" }
    ],
    "threadId": "dev-thread"
  }'
```

Even though the React question was from a week ago, semantic recall finds it and the agent can reference the previous explanation.

## Retrieving message history

Get message history for a thread:

```bash
curl "https://agentc2.ai/agent/api/agents/my-agent/chat?threadId=alice-thread&userId=user_123" \
  -H "Authorization: Bearer $TOKEN"
```

Returns an array of messages in chronological order:

```json
[
    {
        "role": "user",
        "content": "My name is Alice and I love Python programming"
    },
    {
        "role": "assistant",
        "content": "Nice to meet you, Alice! Python is a great language..."
    },
    {
        "role": "user",
        "content": "What are some good Python libraries for data science?"
    }
]
```

## Retention policies

Memory is retained according to:

- **Message history** — Stored indefinitely (no automatic deletion)
- **Semantic recall** — Vector embeddings persist until manually deleted
- **Working memory** — Persists until updated or cleared

<Callout type="warning">
    Memory persists across agent updates, deployments, and version changes. To reset memory, delete
    messages via the API or clear the thread.
</Callout>

## Privacy implications

Memory stores conversation data, which has privacy implications:

1. **Data storage** — Messages are stored in PostgreSQL (encrypted at rest)
2. **Vector embeddings** — Semantic recall creates embeddings of message content
3. **Cross-conversation access** — Semantic recall can access messages from other threads (same resource ID)
4. **Multi-tenant isolation** — Memory is scoped by organization and resource ID

### Best practices

- **Use resource IDs** — Always set `requestContext.userId` for user-scoped memory
- **Separate threads** — Use different thread IDs for different conversation contexts
- **Clear sensitive data** — Implement data retention policies for compliance
- **Encrypt at rest** — Ensure your database encryption is enabled
- **Access controls** — Verify users can only access their own memory

## Performance considerations

Memory retrieval adds latency:

- **lastMessages**: ~10-50ms (direct database query)
- **semanticRecall**: ~100-300ms (vector search + embedding lookup)
- **workingMemory**: ~10-30ms (key-value lookup)

For low-latency use cases, prefer `lastMessages` over `semanticRecall`, or use both with conservative `topK` values.

## Related topics

- **[Agent Configuration](/docs/agents/configuration)** — Configure memory alongside other agent settings
- **[Agents Overview](/docs/agents/overview)** — Learn about the full agent lifecycle
- **[Creating Agents](/docs/agents/creating-agents)** — Create agents with memory enabled
