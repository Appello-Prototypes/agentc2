---
title: "Federation"
description: "Cross-organization trust boundaries, FederationAgreement model, policy enforcement, auditability requirements, federated interactions, and exposure controls."
section: "platform"
order: 5
primaryKeyword: "federation"
relatedSlugs: ["platform/multi-tenancy", "platform/security", "platform/observability"]
pageType: "concept"
ctaLabel: "Launch AgentC2 Workspace"
ctaHref: "/workspace"
---

# Federation

Federation enables secure cross-organization interactions where agents from different organizations can collaborate, share data, and execute workflows across trust boundaries. FederationAgreement models establish bilateral trust relationships with policy enforcement, cryptographic verification, and comprehensive audit logging.

## Federation overview

Federation allows organizations to:

- **Share agents** — Expose agents to trusted partner organizations
- **Cross-org workflows** — Execute workflows that span multiple organizations
- **Data exchange** — Securely share documents, knowledge, and context
- **Collaborative AI** — Enable multi-tenant agent networks

### Trust model

Federation uses a **bilateral trust model**:

1. **Initiator** — Organization requesting federation
2. **Responder** — Organization approving federation
3. **Agreement** — Mutual consent recorded in `FederationAgreement`
4. **Policy** — Access controls and exposure limits
5. **Audit** — Complete audit trail of all federated interactions

<Callout type="info">
    **Federation vs Multi-Tenancy**: Multi-tenancy isolates organizations within a single platform. Federation enables controlled cross-organization collaboration with explicit trust boundaries.
</Callout>

## FederationAgreement model

The `FederationAgreement` model records bilateral trust relationships:

### Agreement structure

```typescript
// Database model: FederationAgreement
{
  id: "fed_123",
  initiatorOrgId: "org_acme",
  responderOrgId: "org_partner",
  status: "active", // "pending", "active", "suspended", "revoked"
  requestedAt: "2026-02-01T12:00:00Z",
  requestedByUserId: "user_456",
  approvedAt: "2026-02-02T10:00:00Z",
  approvedByUserId: "user_789",
  policyJson: {
    allowedOperations: ["agent.invoke", "document.read"],
    exposureControls: {
      maxAgents: 5,
      maxRunsPerDay: 1000,
      allowedWorkspaces: ["prod"]
    },
    dataRetention: {
      traces: "30d",
      documents: "90d"
    }
  },
  keyVersion: 1 // For cryptographic verification
}
```

### Agreement lifecycle

| Status | Description | Actions Allowed |
| ------ | ----------- | --------------- |
| **pending** | Awaiting responder approval | None |
| **active** | Agreement approved, interactions allowed | All per policy |
| **suspended** | Temporarily paused | None (can be resumed) |
| **revoked** | Permanently terminated | None |

### Creating agreements

```bash
# Request federation
curl -X POST https://agentc2.ai/agent/api/federation/agreements \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "responderOrgSlug": "partner-corp",
    "policy": {
      "allowedOperations": ["agent.invoke", "document.read"],
      "exposureControls": {
        "maxAgents": 5,
        "maxRunsPerDay": 1000
      }
    }
  }'

# Approve federation (responder)
curl -X POST https://agentc2.ai/agent/api/federation/agreements/fed_123/approve \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "approvedByUserId": "user_789"
  }'
```

## Policy enforcement

Federation policies control what operations are allowed and what resources can be accessed:

### Allowed operations

| Operation | Description | Example |
| --------- | ----------- | ------- |
| `agent.invoke` | Invoke agents from partner org | Cross-org agent calls |
| `agent.read` | Read agent configuration | View partner agent details |
| `document.read` | Read documents from partner org | Access shared knowledge |
| `document.write` | Create/update documents | Collaborative document editing |
| `workflow.execute` | Execute workflows | Cross-org workflow orchestration |
| `trace.read` | Read execution traces | Debugging federated runs |

### Exposure controls

Limit what resources are exposed:

```json
{
  "exposureControls": {
    "maxAgents": 5,                    // Maximum agents exposed
    "maxRunsPerDay": 1000,             // Daily run quota
    "allowedWorkspaces": ["prod"],     // Only prod workspace
    "allowedAgentSlugs": [             // Specific agents only
      "research-assistant",
      "data-analyst"
    ],
    "blockedAgentSlugs": [             // Explicitly blocked
      "internal-admin"
    ]
  }
}
```

### Policy validation

All federated operations validate policies:

```typescript
// Validate federation policy before operation
async function validateFederationPolicy(
  initiatorOrgId: string,
  responderOrgId: string,
  operation: string
): Promise<boolean> {
  const agreement = await prisma.federationAgreement.findFirst({
    where: {
      initiatorOrgId,
      responderOrgId,
      status: "active"
    }
  })
  
  if (!agreement) return false
  
  const policy = agreement.policyJson as FederationPolicy
  const allowedOps = policy.allowedOperations || []
  
  return allowedOps.includes(operation)
}
```

## Auditability requirements

All federated interactions are logged in `FederationAuditLog`:

### Audit log structure

```typescript
// Database model: FederationAuditLog
{
  id: "audit_123",
  organizationId: "org_acme",
  actorType: "federation_agent", // "user", "agent", "system", "federation_agent"
  actorId: "agent_partner_456",
  action: "agent.invoke",
  resourceType: "agent",
  resourceId: "agent_research",
  targetOrgId: "org_partner",
  agreementId: "fed_123",
  metadata: {
    inputText: "What is...",
    durationMs: 1234,
    tokensUsed: 456
  },
  createdAt: "2026-02-18T12:00:00Z"
}
```

### Audit log fields

| Field | Description | Example |
| ----- | ----------- | ------- |
| `actorType` | Who performed the action | `"federation_agent"` |
| `actorId` | Actor identifier | `"agent_partner_456"` |
| `action` | Operation performed | `"agent.invoke"` |
| `resourceType` | Type of resource accessed | `"agent"`, `"document"` |
| `resourceId` | Resource identifier | `"agent_research"` |
| `targetOrgId` | Target organization | `"org_partner"` |
| `agreementId` | Federation agreement used | `"fed_123"` |
| `metadata` | Operation-specific details | `{ durationMs, tokensUsed }` |

### Querying audit logs

```bash
# Get federation audit logs
curl "https://agentc2.ai/agent/api/federation/audit?startDate=2026-02-01&endDate=2026-02-18" \
  -H "Authorization: Bearer $TOKEN"

# Filter by agreement
curl "https://agentc2.ai/agent/api/federation/agreements/fed_123/audit" \
  -H "Authorization: Bearer $TOKEN"
```

## Federated interactions

Federated operations follow a secure request/response pattern:

### Invoking federated agents

```bash
# Invoke agent from partner organization
curl -X POST https://agentc2.ai/agent/api/federation/invoke \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "targetOrgSlug": "partner-corp",
    "agentSlug": "research-assistant",
    "input": {
      "messages": [
        { "role": "user", "content": "What are the latest AI trends?" }
      ]
    }
  }'
```

### Request flow

1. **Authentication** — Verify initiator has active federation agreement
2. **Policy check** — Validate `agent.invoke` is allowed
3. **Exposure check** — Verify agent is exposed per `exposureControls`
4. **Quota check** — Verify daily run quota not exceeded
5. **Execution** — Execute agent in responder's context
6. **Audit log** — Record interaction in `FederationAuditLog`
7. **Response** — Return result to initiator

### Response structure

```json
{
  "success": true,
  "runId": "run_fed_123",
  "output": {
    "messages": [
      { "role": "assistant", "content": "The latest AI trends include..." }
    ]
  },
  "metadata": {
    "durationMs": 2341,
    "tokensUsed": 456,
    "traceId": "trace_fed_123"
  }
}
```

## Exposure controls

Control what resources are visible to federated partners:

### Agent exposure

```typescript
// Mark agent as federated
await prisma.agent.update({
  where: { id: agentId },
  data: {
    metadata: {
      ...existingMetadata,
      federation: {
        exposed: true,
        exposedToOrgs: ["org_partner"],
        exposurePolicy: {
          allowInvoke: true,
          allowRead: false, // Hide configuration
          maxRunsPerDay: 100
        }
      }
    }
  }
})
```

### Workspace exposure

```typescript
// Expose workspace to federation
await prisma.workspace.update({
  where: { id: workspaceId },
  data: {
    metadata: {
      ...existingMetadata,
      federation: {
        exposed: true,
        exposedToOrgs: ["org_partner"]
      }
    }
  }
})
```

### Document exposure

```typescript
// Share document via federation
await prisma.document.update({
  where: { id: documentId },
  data: {
    metadata: {
      ...existingMetadata,
      federation: {
        exposed: true,
        exposedToOrgs: ["org_partner"],
        accessLevel: "read" // "read" | "write"
      }
    }
  }
})
```

## Cryptographic verification

Federation uses Ed25519 key pairs for cryptographic verification:

### Key pair generation

```typescript
// Generate organization key pair
import { generateKeyPairSync } from "crypto"

const { publicKey, privateKey } = generateKeyPairSync("ed25519", {
  publicKeyEncoding: { type: "spki", format: "pem" },
  privateKeyEncoding: { type: "pkcs8", format: "pem" }
})

// Store encrypted private key
await prisma.organizationKeyPair.create({
  data: {
    organizationId: organizationId,
    publicKey: publicKey,
    encryptedPrivateKey: encryptCredentials({ privateKey }),
    keyVersion: 1,
    status: "active"
  })
})
```

### Request signing

Federated requests are signed with the organization's private key:

```typescript
// Sign federated request
import { createSign } from "crypto"

const sign = createSign("SHA256")
sign.update(JSON.stringify(requestPayload))
sign.end()

const signature = sign.sign(privateKey, "base64")

// Include signature in request headers
headers["X-Federation-Signature"] = signature
headers["X-Federation-Org"] = organizationSlug
headers["X-Federation-Key-Version"] = "1"
```

### Signature verification

Responders verify request signatures:

```typescript
// Verify federated request signature
import { createVerify } from "crypto"

const publicKey = await getOrganizationPublicKey(initiatorOrgSlug, keyVersion)
const verify = createVerify("SHA256")
verify.update(JSON.stringify(requestPayload))
verify.end()

const isValid = verify.verify(publicKey, signature, "base64")
if (!isValid) {
  throw new Error("Invalid federation signature")
}
```

## Best practices

1. **Minimize exposure** — Only expose necessary resources
2. **Set quotas** — Limit `maxRunsPerDay` to prevent abuse
3. **Monitor audit logs** — Review federated interactions regularly
4. **Rotate keys** — Rotate organization key pairs periodically
5. **Use specific policies** — Prefer `allowedAgentSlugs` over broad exposure
6. **Review agreements** — Periodically review active agreements
7. **Suspend before revoke** — Suspend agreements before permanent revocation

## Related topics

- **[Multi-Tenancy](/docs/platform/multi-tenancy)** — Organization boundaries and isolation
- **[Security](/docs/platform/security)** — Credential encryption and key management
- **[Observability](/docs/platform/observability)** — Audit logging and trace visibility
