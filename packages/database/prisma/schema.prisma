// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Better Auth Models
model User {
    id                     String                  @id @default(cuid())
    name                   String
    email                  String                  @unique
    emailVerified          Boolean                 @default(false)
    image                  String?
    createdAt              DateTime                @default(now())
    updatedAt              DateTime                @updatedAt
    sessions               Session[]
    accounts               Account[]
    agents                 Agent[]
    integrationConnections IntegrationConnection[]
    supportTickets         SupportTicket[]

    @@map("user")
}

model Session {
    id        String   @id @default(cuid())
    expiresAt DateTime
    token     String   @unique
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
    @@map("session")
}

model Account {
    id                    String    @id @default(cuid())
    accountId             String
    providerId            String
    userId                String
    user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken           String?
    refreshToken          String?
    idToken               String?
    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    password              String?
    createdAt             DateTime  @default(now())
    updatedAt             DateTime  @updatedAt

    @@index([userId])
    @@map("account")
}

model Verification {
    id         String    @id @default(cuid())
    identifier String
    value      String
    expiresAt  DateTime
    createdAt  DateTime? @default(now())
    updatedAt  DateTime? @updatedAt

    @@map("verification")
}

// ==============================
// Multi-Tenant Organization Models
// ==============================

// Organization - Company or team boundary for multi-tenancy
model Organization {
    id          String   @id @default(cuid())
    name        String
    slug        String   @unique // URL-safe identifier
    description String?
    logoUrl     String?
    metadata    Json?
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // Lifecycle
    status          String    @default("active") // "provisioning","active","trial","suspended","past_due","deactivated"
    suspendedAt     DateTime?
    suspendedReason String?   @db.Text
    deletedAt       DateTime? // soft delete
    trialEndsAt     DateTime?

    // Denormalized limits (from Plan, for fast enforcement)
    maxAgents       Int?
    maxWorkspaces   Int?
    maxRunsPerMonth Int?
    maxSeats        Int?
    maxStorageBytes BigInt? // Workspace file storage quota (null = unlimited)

    // Billing reference
    stripeCustomerId String? @unique

    // Risk
    riskScore       Float?    @default(0)
    lastHealthCheck DateTime?

    // Relations
    workspaces             Workspace[]
    memberships            Membership[]
    credentials            ToolCredential[]
    integrationConnections IntegrationConnection[]
    identityMappings       IdentityMapping[]
    approvalRequests       ApprovalRequest[]
    crmAuditLogs           CrmAuditLog[]
    emailThreads           EmailThread[]
    chatMessages           ChatMessage[]
    meetingTranscripts     MeetingTranscript[]
    actionItems            ActionItem[]
    invites                OrganizationInvite[]
    domains                OrganizationDomain[]

    // Admin portal relations
    featureFlagOverrides  FeatureFlagOverride[]
    lifecycleEvents       TenantLifecycleEvent[]
    impersonationSessions ImpersonationSession[]
    supportTickets        SupportTicket[]

    // Security
    keyPairs OrganizationKeyPair[]

    // Federation audit
    federationAuditLogs FederationAuditLog[]

    // Federation
    federationInitiated FederationAgreement[] @relation("FederationInitiator")
    federationReceived  FederationAgreement[] @relation("FederationResponder")
    federationExposures FederationExposure[]

    // Infrastructure
    provisionedResources ProvisionedResource[]

    // Agent Instances
    agentInstances AgentInstance[]

    // Org-wide guardrail policy
    orgGuardrailPolicy OrgGuardrailPolicy?

    // Dark Factory
    pipelinePolicy    PipelinePolicy?
    repositoryConfigs RepositoryConfig[]

    // Storage tracking
    workspaceStorageUsage WorkspaceStorageUsage[]

    // Budget & Billing
    subscription    OrgSubscription?
    orgBudgetPolicy OrgBudgetPolicy?
    budgetAlerts    BudgetAlert[]

    @@index([slug])
    @@index([status])
    @@map("organization")
}

// Workspace - Environment within an org (dev/staging/prod)
model Workspace {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    name           String
    slug           String // URL-safe identifier within org
    environment    String       @default("development") // "development", "staging", "production"
    description    String?
    isDefault      Boolean      @default(false)
    metadata       Json?
    createdAt      DateTime     @default(now())
    updatedAt      DateTime     @updatedAt

    // Relations
    agents            Agent[]
    schedules         AgentSchedule[]
    triggers          AgentTrigger[]
    workflows         Workflow[]
    networks          Network[]
    bimModels         BimModel[]
    GmailIntegration  GmailIntegration[]
    TriggerEvent      TriggerEvent[]
    EmailThread       EmailThread[]
    ChatMessage       ChatMessage[]
    MeetingTranscript MeetingTranscript[]
    ActionItem        ActionItem[]
    ApprovalRequest   ApprovalRequest[]
    CrmAuditLog       CrmAuditLog[]
    documents         Document[]
    skills            Skill[]

    @@unique([organizationId, slug])
    @@index([organizationId])
    @@map("workspace")
}

// Membership - User's role in an organization
model Membership {
    id                    String       @id @default(cuid())
    userId                String
    organizationId        String
    organization          Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    role                  String       @default("member") // "owner", "admin", "member", "viewer"
    permissions           String[]     @default([]) // Granular permissions: "guardrail_override", etc.
    onboardingCompletedAt DateTime?
    onboardingStep        String?

    // Onboarding analytics (Phase 1)
    onboardingPath            String? // "google_oauth" | "email_password" | "invite_join" | "domain_join"
    connectedDuringOnboarding String[] @default([]) // Integration keys connected during onboarding
    setupProgress             Json? // Connection Power Bar state

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([userId, organizationId])
    @@index([userId])
    @@index([organizationId])
    @@map("membership")
}

// Organization Invite - Code-based org join
model OrganizationInvite {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    code           String       @unique
    expiresAt      DateTime?
    maxUses        Int?
    usedCount      Int          @default(0)
    isActive       Boolean      @default(true)
    createdBy      String?
    metadata       Json?
    createdAt      DateTime     @default(now())
    updatedAt      DateTime     @updatedAt

    @@index([organizationId])
    @@map("organization_invite")
}

// Organization Domain - Email domain mapping to org
model OrganizationDomain {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    domain         String       @unique
    isPrimary      Boolean      @default(false)
    createdAt      DateTime     @default(now())
    updatedAt      DateTime     @updatedAt

    @@index([organizationId])
    @@map("organization_domain")
}

// ToolCredential - Scoped credentials for MCP/tool access per organization
model ToolCredential {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    toolId         String // MCP server or tool key (e.g., "hubspot", "jira")
    name           String
    credentials    Json // Encrypted credentials
    isActive       Boolean      @default(true)
    lastUsedAt     DateTime?
    createdAt      DateTime     @default(now())
    updatedAt      DateTime     @updatedAt
    createdBy      String?

    @@unique([organizationId, toolId])
    @@index([organizationId])
    @@map("tool_credential")
}

// Integration Provider - Catalog of available integrations (built-in + custom)
model IntegrationProvider {
    id            String   @id @default(cuid())
    key           String   @unique // Provider key (e.g., "hubspot", "gmail")
    name          String
    description   String?
    category      String // "crm", "communication", "web", "knowledge", "automation", "productivity"
    authType      String // "apiKey", "oauth", "none", "webhook", "custom"
    providerType  String // "mcp", "oauth", "webhook", "custom"
    maturityLevel String   @default("visible") // "visible" (default) or "internal" (AI models, channels - hidden from main integrations page)
    isActive      Boolean  @default(true)
    configJson    Json? // Custom server config, required fields, etc.
    actionsJson   Json? // Cached action metadata
    triggersJson  Json? // Cached trigger metadata
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    // Relations
    connections IntegrationConnection[]

    @@map("integration_provider")
}

// Integration Connection - Organization/User scoped connection instances
model IntegrationConnection {
    id             String              @id @default(cuid())
    providerId     String
    provider       IntegrationProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)
    organizationId String
    organization   Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    userId         String?
    user           User?               @relation(fields: [userId], references: [id], onDelete: SetNull)
    scope          String              @default("org") // "org" or "user"
    name           String
    isDefault      Boolean             @default(false)
    isActive       Boolean             @default(true)
    credentials    Json?
    metadata       Json?
    lastUsedAt     DateTime?
    lastTestedAt   DateTime?
    errorMessage   String?             @db.Text
    webhookPath    String?
    webhookSecret  String?
    agentTriggerId String?
    agentTrigger   AgentTrigger?       @relation(fields: [agentTriggerId], references: [id], onDelete: SetNull)
    createdAt      DateTime            @default(now())
    updatedAt      DateTime            @updatedAt

    // Relations
    gmailIntegrations       GmailIntegration[]
    emailThreads            EmailThread[]
    chatMessages            ChatMessage[]
    meetingTranscripts      MeetingTranscript[]
    crmAuditLogs            CrmAuditLog[]
    EmailMessage            EmailMessage[]
    webhookSubscriptions    WebhookSubscription[]
    calendarEvents          CalendarEvent[]
    slackChannelPreferences SlackChannelPreference[]
    integrationEvents       IntegrationEvent[]

    @@index([organizationId])
    @@index([providerId])
    @@index([userId])
    @@index([agentTriggerId])
    @@map("integration_connection")
}

// Integration Event - Lifecycle event log for integration connections
model IntegrationEvent {
    id           String                @id @default(cuid())
    connectionId String
    connection   IntegrationConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
    eventType    String // created, tested, failed, reconnected, token_refreshed, token_expired, disconnected, health_check.passed, health_check.failed
    success      Boolean               @default(true)
    message      String?               @db.Text
    metadata     Json? // tool count, latency, error details, etc.
    durationMs   Int? // duration of the operation in milliseconds
    createdAt    DateTime              @default(now())

    @@index([connectionId, createdAt])
    @@index([eventType])
    @@map("integration_event")
}

// Email Thread - Normalized email threads for Gmail/Outlook
model EmailThread {
    id                      String                 @id @default(cuid())
    organizationId          String
    organization            Organization           @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    workspaceId             String?
    workspace               Workspace?             @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    integrationConnectionId String?
    integrationConnection   IntegrationConnection? @relation(fields: [integrationConnectionId], references: [id], onDelete: SetNull)
    threadId                String
    subject                 String?
    participantsJson        Json?
    lastMessageAt           DateTime?
    lastInboundAt           DateTime?
    lastOutboundAt          DateTime?
    status                  String?
    summary                 String?                @db.Text
    createdAt               DateTime               @default(now())
    updatedAt               DateTime               @updatedAt

    // Relations
    messages EmailMessage[]

    @@unique([integrationConnectionId, threadId])
    @@index([organizationId])
    @@index([workspaceId])
    @@map("email_thread")
}

// Email Message - Normalized email messages
model EmailMessage {
    id                      String                 @id @default(cuid())
    threadId                String
    thread                  EmailThread            @relation(fields: [threadId], references: [id], onDelete: Cascade)
    integrationConnectionId String?
    integrationConnection   IntegrationConnection? @relation(fields: [integrationConnectionId], references: [id], onDelete: SetNull)
    messageId               String
    direction               String? // "inbound" | "outbound"
    fromAddress             String?
    toAddressesJson         Json?
    ccAddressesJson         Json?
    bccAddressesJson        Json?
    subject                 String?
    snippet                 String?
    bodyText                String?                @db.Text
    bodyHtml                String?                @db.Text
    receivedAt              DateTime?
    labelsJson              Json?
    hasAttachments          Boolean                @default(false)
    attachmentsJson         Json?
    metadata                Json?
    createdAt               DateTime               @default(now())
    updatedAt               DateTime               @updatedAt

    @@unique([integrationConnectionId, messageId])
    @@index([threadId])
    @@map("email_message")
}

// Chat Message - Normalized chat events (Slack, Teams, etc.)
model ChatMessage {
    id                      String                 @id @default(cuid())
    organizationId          String
    organization            Organization           @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    workspaceId             String?
    workspace               Workspace?             @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    integrationConnectionId String?
    integrationConnection   IntegrationConnection? @relation(fields: [integrationConnectionId], references: [id], onDelete: SetNull)
    channelId               String
    messageTs               String
    userId                  String?
    text                    String?                @db.Text
    isEdited                Boolean                @default(false)
    isDeleted               Boolean                @default(false)
    reactionsJson           Json?
    attachmentsJson         Json?
    metadata                Json?
    createdAt               DateTime               @default(now())
    updatedAt               DateTime               @updatedAt

    @@unique([integrationConnectionId, messageTs])
    @@index([organizationId])
    @@index([workspaceId])
    @@map("chat_message")
}

// Meeting Transcript - Normalized meeting transcripts (Fathom, Zoom, etc.)
model MeetingTranscript {
    id                      String                 @id @default(cuid())
    organizationId          String
    organization            Organization           @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    workspaceId             String?
    workspace               Workspace?             @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    integrationConnectionId String?
    integrationConnection   IntegrationConnection? @relation(fields: [integrationConnectionId], references: [id], onDelete: SetNull)
    meetingId               String
    title                   String?
    startedAt               DateTime?
    endedAt                 DateTime?
    participantsJson        Json?
    transcriptText          String?                @db.Text
    summaryText             String?                @db.Text
    actionItemsJson         Json?
    sentimentJson           Json?
    metadata                Json?
    createdAt               DateTime               @default(now())
    updatedAt               DateTime               @updatedAt

    @@unique([integrationConnectionId, meetingId])
    @@index([organizationId])
    @@index([workspaceId])
    @@map("meeting_transcript")
}

// Action Item - Extracted tasks from emails/meetings/chats
model ActionItem {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    workspaceId    String?
    workspace      Workspace?   @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    sourceType     String // "email" | "meeting" | "chat" | "crm"
    sourceId       String?
    title          String
    description    String?      @db.Text
    status         String       @default("open")
    dueAt          DateTime?
    assignee       String?
    metadata       Json?
    createdAt      DateTime     @default(now())
    updatedAt      DateTime     @updatedAt

    @@index([organizationId])
    @@index([workspaceId])
    @@index([status])
    @@map("action_item")
}

// Approval Request - Approval-first workflow tracking
model ApprovalRequest {
    id             String        @id @default(cuid())
    organizationId String
    organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    workspaceId    String?
    workspace      Workspace?    @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    agentId        String?
    agent          Agent?        @relation(fields: [agentId], references: [id], onDelete: SetNull)
    triggerEventId String?
    triggerEvent   TriggerEvent? @relation(fields: [triggerEventId], references: [id], onDelete: SetNull)
    workflowRunId  String?
    workflowRun    WorkflowRun?  @relation(fields: [workflowRunId], references: [id], onDelete: SetNull)
    sourceType     String
    sourceId       String?
    status         String        @default("pending") // "pending" | "approved" | "rejected"
    requestedBy    String?
    requestedAt    DateTime      @default(now())
    decidedBy      String?
    decidedAt      DateTime?
    decisionReason String?       @db.Text
    payloadJson    Json?
    slackChannelId String?
    slackMessageTs String?
    metadata       Json?
    createdAt      DateTime      @default(now())
    updatedAt      DateTime      @updatedAt

    @@index([organizationId])
    @@index([workspaceId])
    @@index([agentId])
    @@index([status])
    @@map("approval_request")
}

// Identity Mapping - Cross-system identity resolution
model IdentityMapping {
    id               String       @id @default(cuid())
    organizationId   String
    organization     Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    email            String?
    domain           String?
    slackUserId      String?
    hubspotContactId String?
    hubspotCompanyId String?
    metadata         Json?
    createdAt        DateTime     @default(now())
    updatedAt        DateTime     @updatedAt

    @@unique([organizationId, email])
    @@index([organizationId])
    @@map("identity_mapping")
}

// CRM Audit Log - Track CRM mutations and notes
model CrmAuditLog {
    id                      String                 @id @default(cuid())
    organizationId          String
    organization            Organization           @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    workspaceId             String?
    workspace               Workspace?             @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    integrationConnectionId String?
    integrationConnection   IntegrationConnection? @relation(fields: [integrationConnectionId], references: [id], onDelete: SetNull)
    eventType               String
    recordType              String?
    recordId                String?
    sourceType              String?
    sourceId                String?
    payloadJson             Json?
    actorUserId             String?
    createdAt               DateTime               @default(now())

    @@index([organizationId])
    @@index([recordType, recordId])
    @@map("crm_audit_log")
}

// Agent Type Enum
enum AgentType {
    SYSTEM // Seeded from code, protected from deletion (core platform agents)
    USER // User-created, fully editable
    DEMO // Example/demo agents, discoverable but not production
}

enum AgentVisibility {
    PRIVATE // Only the owner can see this agent
    ORGANIZATION // Anyone in the same organization can use this agent
    PUBLIC // Anyone can access this agent (embed, API, etc.)
}

// Run Status Enum
enum RunStatus {
    QUEUED
    RUNNING
    COMPLETED
    FAILED
    CANCELLED
}

// Run Type Enum
enum RunType {
    TEST
    PROD
    AB
}

// Run Environment Enum
enum RunEnvironment {
    DEVELOPMENT
    STAGING
    PRODUCTION
}

// Run Trigger Enum
enum RunTriggerType {
    MANUAL
    API
    SCHEDULED
    WEBHOOK
    TOOL
    TEST
    RETRY
}

enum TriggerEventStatus {
    RECEIVED
    FILTERED
    QUEUED
    SKIPPED
    REJECTED
    NO_MATCH
    ERROR
}

// Workflow Type Enum
enum WorkflowType {
    SYSTEM // Code-defined, protected
    USER // User-created
}

// Network Type Enum
enum NetworkType {
    SYSTEM
    USER
}

// Deployment Status Enum
enum DeploymentStatus {
    DRAFT
    TESTING
    PENDING_REVIEW
    APPROVED
    DEPLOYED
    DEPRECATED
    ARCHIVED
}

// Alert Severity Enum
enum AlertSeverity {
    INFO
    WARNING
    CRITICAL
}

// Alert Source Enum
enum AlertSource {
    COST
    GUARDRAIL
    EVAL
    SYSTEM
}

// Guardrail Event Type Enum
enum GuardrailEventType {
    BLOCKED
    MODIFIED
    FLAGGED
}

// Agents - Database-backed agent configurations (Mastra-aligned)
model Agent {
    id          String  @id @default(cuid())
    slug        String // URL-safe identifier (unique per workspace, not globally)
    name        String
    description String?

    // Instructions - static or templated
    instructions         String  @db.Text
    instructionsTemplate String? @db.Text // Template with {{userId}}, {{userName}}, etc.

    // Model configuration
    modelProvider String // "openai", "anthropic", "google"
    modelName     String // "gpt-4o", "claude-sonnet-4-20250514"
    temperature   Float? @default(0.7)
    maxTokens     Int?
    modelConfig   Json? // Provider-specific: {reasoning: {type: "enabled"}, toolChoice: "auto"}
    routingConfig Json? // {mode: "locked"|"auto", fastModel: {provider, name}, escalationModel: {provider, name}, confidenceThreshold: 0.7, budgetAware: true}

    // Tool configuration (junction table)
    tools AgentTool[]

    // Network orchestration
    subAgents String[] @default([]) // Agent slugs this agent can delegate to
    workflows String[] @default([]) // Workflow IDs

    // Memory configuration (Mastra Memory pattern)
    memoryEnabled Boolean @default(false)
    memoryConfig  Json? // {lastMessages, semanticRecall, workingMemory}

    // Multi-step workflows
    maxSteps Int? @default(5)

    // Evaluation configuration
    scorers String[] @default([])

    // Permissions/tenancy
    type        AgentType       @default(USER)
    tenantId    String? // Multi-tenant isolation (legacy, use workspaceId)
    workspaceId String?
    workspace   Workspace?      @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    ownerId     String?
    owner       User?           @relation(fields: [ownerId], references: [id])
    visibility  AgentVisibility @default(PRIVATE)
    publicToken String?         @unique // Token for public embed access

    // Policies
    requiresApproval Boolean @default(false) // Require human approval for runs
    maxSpendUsd      Float? // Max spend per run in USD
    autoVectorize    Boolean @default(true) // Auto-embed outputs into RAG knowledge base

    // Metadata
    metadata          Json?
    isActive          Boolean @default(true)
    isOnboardingAgent Boolean @default(false) // Auto-created during onboarding
    version           Int     @default(1)

    // Audit
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    createdBy String?

    // Relations
    versions               AgentVersion[]
    runs                   AgentRun[]
    traces                 AgentTrace[]
    alerts                 AgentAlert[]
    evaluations            AgentEvaluation[]
    feedback               AgentFeedback[]
    testCases              AgentTestCase[]
    testRuns               AgentTestRun[]
    conversations          AgentConversation[]
    budgetPolicy           BudgetPolicy?
    costEvents             CostEvent[]
    costDaily              AgentCostDaily[]
    modelCostDaily         AgentModelCostDaily[]
    costRecommendations    CostRecommendation[]
    guardrailPolicy        GuardrailPolicy?
    guardrailEvents        GuardrailEvent[]
    statsDaily             AgentStatsDaily[]
    metricDaily            AgentMetricDaily[]
    toolMetricDaily        AgentToolMetricDaily[]
    modelMetricDaily       AgentModelMetricDaily[]
    qualityMetricDaily     AgentQualityMetricDaily[]
    feedbackAggregateDaily AgentFeedbackAggregateDaily[]
    versionStats           AgentVersionStats[]
    themes                 EvaluationTheme[]
    insights               Insight[]
    learningSessions       LearningSession[]
    learningMetricDaily    LearningMetricDaily[]
    learningPolicy         LearningPolicy?
    simulationSessions     SimulationSession[]
    schedules              AgentSchedule[]
    triggers               AgentTrigger[]
    networkPrimitives      NetworkPrimitive[]
    GmailIntegration       GmailIntegration[]
    TriggerEvent           TriggerEvent[]
    ApprovalRequest        ApprovalRequest[]
    skills                 AgentSkill[]
    scorecard              AgentScorecard?
    calibrationChecks      CalibrationCheck[]
    recommendations        AgentRecommendation[]
    healthScores           AgentHealthScore[]
    backlog                Backlog?
    outputActions          OutputAction[]
    federationExposures    FederationExposure[]
    instances              AgentInstance[]
    storageUsage           WorkspaceStorageUsage[]

    @@unique([workspaceId, slug]) // Per-workspace slug uniqueness (NULLs treated as distinct in PG)
    @@index([slug])
    @@index([workspaceId])
    @@index([ownerId])
    @@index([tenantId])
    @@index([type])
    @@index([visibility])
    @@map("agent")
}

// Workspace file storage tracking per agent per org
model WorkspaceStorageUsage {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    agentId        String
    agent          Agent        @relation(fields: [agentId], references: [id], onDelete: Cascade)
    totalBytes     BigInt       @default(0)
    fileCount      Int          @default(0)
    lastWriteAt    DateTime?
    updatedAt      DateTime     @updatedAt

    @@unique([organizationId, agentId])
    @@index([organizationId])
    @@map("workspace_storage_usage")
}

// Agent-Tool Junction Table
model AgentTool {
    id      String @id @default(cuid())
    agentId String
    agent   Agent  @relation(fields: [agentId], references: [id], onDelete: Cascade)
    toolId  String // Tool registry key (e.g., "calculator", "web-fetch")
    config  Json? // Tool-specific: {inputSchema, outputSchema, description override}

    @@unique([agentId, toolId])
    @@map("agent_tool")
}

// Agent Version History
model AgentVersion {
    id            String   @id @default(cuid())
    agentId       String
    agent         Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId      String?
    version       Int
    description   String?  @db.Text
    instructions  String   @db.Text
    modelProvider String
    modelName     String
    changesJson   Json? // Description of changes from previous version
    snapshot      Json // Full agent config + tool IDs + scorer IDs at this version
    createdAt     DateTime @default(now())
    createdBy     String?

    // Relations
    versionStats AgentVersionStats[]

    @@unique([agentId, version])
    @@index([agentId, version])
    @@map("agent_version")
}

// Agent Schedule - Cron-based recurring execution
model AgentSchedule {
    id          String     @id @default(cuid())
    agentId     String
    agent       Agent      @relation(fields: [agentId], references: [id], onDelete: Cascade)
    workspaceId String?
    workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    name        String
    description String?
    cronExpr    String // Cron expression (e.g., "0 17 * * FRI")
    timezone    String     @default("UTC")
    inputJson   Json? // Default input for scheduled runs
    isActive    Boolean    @default(true)
    lastRunAt   DateTime?
    nextRunAt   DateTime?
    runCount    Int        @default(0)
    createdAt   DateTime   @default(now())
    updatedAt   DateTime   @updatedAt
    createdBy   String?

    @@index([agentId])
    @@index([workspaceId])
    @@index([isActive, nextRunAt])
    @@map("agent_schedule")
}

// Agent Trigger - Event-based invocation
model AgentTrigger {
    id                    String                  @id @default(cuid())
    agentId               String
    agent                 Agent                   @relation(fields: [agentId], references: [id], onDelete: Cascade)
    workspaceId           String?
    workspace             Workspace?              @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    name                  String
    description           String?
    triggerType           String // "webhook", "event", "mcp"
    eventName             String? // Event name to listen for
    webhookPath           String? // Unique webhook path for this trigger
    webhookSecret         String? // Secret for webhook validation
    filterJson            Json? // Conditions to match before triggering
    inputMapping          Json? // How to map trigger payload to agent input
    isActive              Boolean                 @default(true)
    lastTriggeredAt       DateTime?
    triggerCount          Int                     @default(0)
    createdAt             DateTime                @default(now())
    updatedAt             DateTime                @updatedAt
    createdBy             String?
    TriggerEvent          TriggerEvent[]
    IntegrationConnection IntegrationConnection[]

    @@unique([webhookPath])
    @@index([agentId])
    @@index([workspaceId])
    @@index([triggerType])
    @@index([eventName])
    @@map("agent_trigger")
}

// Trigger Event - Unified execution origin log for agents, workflows, and networks
model TriggerEvent {
    id               String             @id @default(cuid())
    triggerId        String?
    trigger          AgentTrigger?      @relation(fields: [triggerId], references: [id], onDelete: SetNull)
    agentId          String?
    agent            Agent?             @relation(fields: [agentId], references: [id], onDelete: SetNull)
    workspaceId      String?
    workspace        Workspace?         @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    runId            String?
    run              AgentRun?          @relation(fields: [runId], references: [id], onDelete: SetNull)
    status           TriggerEventStatus @default(RECEIVED)
    sourceType       String // "webhook", "event", "integration", "schedule", "slack", "api", "chat", "mcp", "simulation"
    triggerType      String? // "webhook", "event", "mcp", "schedule"
    integrationKey   String? // e.g., "gmail"
    integrationId    String?
    eventName        String?
    webhookPath      String?
    payloadJson      Json?
    payloadPreview   String?            @db.Text
    payloadTruncated Boolean            @default(false)
    errorMessage     String?            @db.Text
    metadata         Json?

    // Entity type discrimination: "agent", "workflow", "network"
    entityType String?

    // Workflow support
    workflowId    String?
    workflow      Workflow?    @relation(fields: [workflowId], references: [id], onDelete: SetNull)
    workflowRunId String?      @unique
    workflowRun   WorkflowRun? @relation(fields: [workflowRunId], references: [id], onDelete: SetNull)

    // Network support
    networkId    String?
    network      Network?    @relation(fields: [networkId], references: [id], onDelete: SetNull)
    networkRunId String?     @unique
    networkRun   NetworkRun? @relation(fields: [networkRunId], references: [id], onDelete: SetNull)

    createdAt       DateTime          @default(now())
    updatedAt       DateTime          @updatedAt
    ApprovalRequest ApprovalRequest[]

    @@unique([runId])
    @@index([triggerId, createdAt])
    @@index([triggerId, eventName])
    @@index([agentId, createdAt])
    @@index([workspaceId, createdAt])
    @@index([status, createdAt])
    @@index([eventName])
    @@index([integrationKey])
    @@index([entityType, createdAt])
    @@index([workflowId, createdAt])
    @@index([networkId, createdAt])
    @@index([sourceType, createdAt])
    @@map("trigger_event")
}

// Gmail Integration - Links Gmail accounts to agents and Slack notifications
model GmailIntegration {
    id                      String                 @id @default(cuid())
    agentId                 String
    agent                   Agent                  @relation(fields: [agentId], references: [id], onDelete: Cascade)
    workspaceId             String?
    workspace               Workspace?             @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
    integrationConnectionId String?
    integrationConnection   IntegrationConnection? @relation(fields: [integrationConnectionId], references: [id], onDelete: SetNull)
    gmailAddress            String
    slackUserId             String
    historyId               String?
    watchExpiration         DateTime?
    isActive                Boolean                @default(true)
    createdAt               DateTime               @default(now())
    updatedAt               DateTime               @updatedAt

    @@unique([agentId, gmailAddress])
    @@index([agentId])
    @@index([workspaceId])
    @@index([gmailAddress])
    @@index([integrationConnectionId])
    @@map("gmail_integration")
}

// Legacy Mastra tables (not managed by Prisma migrations)
model MastraAiSpan {
    traceId        String
    spanId         String
    name           String
    spanType       String
    isEvent        Boolean
    startedAt      DateTime  @db.Timestamp(6)
    parentSpanId   String?
    entityType     String?
    entityId       String?
    entityName     String?
    userId         String?
    organizationId String?
    resourceId     String?
    runId          String?
    sessionId      String?
    threadId       String?
    requestId      String?
    environment    String?
    source         String?
    serviceName    String?
    scope          Json?
    metadata       Json?
    tags           Json?
    attributes     Json?
    links          Json?
    input          Json?
    output         Json?
    error          Json?
    endedAt        DateTime? @db.Timestamp(6)
    createdAt      DateTime  @db.Timestamp(6)
    updatedAt      DateTime? @db.Timestamp(6)
    startedAtZ     DateTime? @default(now()) @db.Timestamptz(6)
    endedAtZ       DateTime? @default(now()) @db.Timestamptz(6)
    createdAtZ     DateTime? @default(now()) @db.Timestamptz(6)
    updatedAtZ     DateTime? @default(now()) @db.Timestamptz(6)

    @@id([traceId, spanId], map: "public_mastra_ai_spans_traceid_spanid_pk")
    @@index([entityType, entityId], map: "mastra_ai_spans_entitytype_entityid_idx")
    @@index([entityType, entityName], map: "mastra_ai_spans_entitytype_entityname_idx")
    @@index([metadata], map: "mastra_ai_spans_metadata_gin_idx", type: Gin)
    @@index([name])
    @@index([organizationId, userId], map: "mastra_ai_spans_orgid_userid_idx")
    @@index([parentSpanId, startedAt(sort: Desc)], map: "mastra_ai_spans_parentspanid_startedat_idx")
    @@index([spanType, startedAt(sort: Desc)], map: "mastra_ai_spans_spantype_startedat_idx")
    @@index([tags], map: "mastra_ai_spans_tags_gin_idx", type: Gin)
    @@index([traceId, startedAt(sort: Desc)], map: "mastra_ai_spans_traceid_startedat_idx")
    @@map("mastra_ai_spans")
    @@ignore
}

model MastraMessage {
    id         String    @id
    thread_id  String
    content    String
    role       String
    type       String
    createdAt  DateTime  @db.Timestamp(6)
    resourceId String?
    createdAtZ DateTime? @default(now()) @db.Timestamptz(6)

    @@index([thread_id, createdAt(sort: Desc)], map: "mastra_messages_thread_id_createdat_idx")
    @@map("mastra_messages")
    @@ignore
}

model MastraResource {
    id            String    @id
    workingMemory String?
    metadata      Json?
    createdAt     DateTime  @db.Timestamp(6)
    updatedAt     DateTime  @db.Timestamp(6)
    createdAtZ    DateTime? @default(now()) @db.Timestamptz(6)
    updatedAtZ    DateTime? @default(now()) @db.Timestamptz(6)

    @@map("mastra_resources")
    @@ignore
}

model MastraThread {
    id         String    @id
    resourceId String
    title      String
    metadata   Json?
    createdAt  DateTime  @db.Timestamp(6)
    updatedAt  DateTime  @db.Timestamp(6)
    createdAtZ DateTime? @default(now()) @db.Timestamptz(6)
    updatedAtZ DateTime? @default(now()) @db.Timestamptz(6)

    @@index([resourceId, createdAt(sort: Desc)], map: "mastra_threads_resourceid_createdat_idx")
    @@map("mastra_threads")
    @@ignore
}

// RAG Vector Store - Managed by @mastra/pg PgVector, NOT by Prisma.
// Declared here with @@ignore so `prisma db push` does not drop the table.
model RagDocument {
    id        Int                          @id @default(autoincrement())
    vectorId  String                       @unique @map("vector_id")
    embedding Unsupported("vector(1536)")?
    metadata  Json?                        @default("{}")

    @@map("rag_documents")
    @@ignore
}

// Legacy Stored Agents - Kept for backwards compatibility during migration
model StoredAgent {
    id            String   @id @default(cuid())
    name          String
    description   String?
    instructions  String   @db.Text
    modelProvider String // "openai", "anthropic", etc.
    modelName     String // "gpt-4o", "claude-sonnet", etc.
    temperature   Float?   @default(0.7)
    tools         String[] // Tool names to attach
    memory        Boolean  @default(false)
    metadata      Json?
    isActive      Boolean  @default(true)
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    @@map("stored_agent")
}

// ==============================
// Channel System Models
// ==============================

// Channel Session - Tracks conversations per channel/user
model ChannelSession {
    id         String   @id @default(cuid())
    channel    String // "whatsapp" | "telegram" | "voice"
    channelId  String // Phone number, chat ID, or call SID
    agentSlug  String // Which agent handles this conversation
    metadata   Json? // Channel-specific data (e.g., username, group info)
    lastActive DateTime @default(now())
    createdAt  DateTime @default(now())

    @@unique([channel, channelId])
    @@index([channel])
    @@index([agentSlug])
    @@map("channel_session")
}

// Channel Credentials - Stores encrypted credentials for each channel
model ChannelCredentials {
    id          String   @id @default(cuid())
    channel     String   @unique // "whatsapp" | "telegram" | "voice"
    credentials Json // Encrypted credentials (WhatsApp session, bot tokens, etc.)
    isActive    Boolean  @default(true)
    updatedAt   DateTime @updatedAt

    @@map("channel_credentials")
}

// Voice Call Log - Tracks voice call history
model VoiceCallLog {
    id           String    @id @default(cuid())
    callSid      String    @unique // Twilio call SID
    direction    String // "inbound" | "outbound"
    fromNumber   String
    toNumber     String
    agentSlug    String?
    status       String // "ringing" | "in-progress" | "completed" | "failed" | "busy" | "no-answer"
    duration     Int? // Duration in seconds
    recordingUrl String?
    transcript   String?   @db.Text
    metadata     Json?
    startedAt    DateTime  @default(now())
    endedAt      DateTime?
    createdAt    DateTime  @default(now())

    @@index([fromNumber])
    @@index([toNumber])
    @@index([agentSlug])
    @@map("voice_call_log")
}

// Voice Agent Trace - Full observability for voice agent conversations
model VoiceAgentTrace {
    id        String   @id @default(cuid())
    traceId   String   @unique // External trace ID
    timestamp DateTime @default(now())

    // Conversation content
    input  String @db.Text // User's question
    output String @db.Text // Agent's response

    // Model configuration
    model Json // {provider, name, temperature}

    // Tools
    availableTools String[] // Tool names available to agent
    toolCalls      Json // Array of {name, input, output, success, error, durationMs}

    // Execution trace
    steps Json // Array of {step, type, content, timestamp, toolCall?}

    // Performance
    durationMs Int
    tokens     Json? // {prompt, completion, total}

    // Evaluation scores
    scores Json // {helpfulness?: {score, reasoning}, relevancy?: {score}}

    // Metadata
    metadata Json // {source, agentSlug, agentSource, elevenlabsAgentId, maxSteps}

    // Audit
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([timestamp])
    @@index([createdAt])
    @@map("voice_agent_trace")
}

// ==============================
// Agent Workspace Models
// ==============================

// Agent Run - Execution history
model AgentRun {
    id               String    @id @default(cuid())
    agentId          String
    agent            Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId         String?
    runType          RunType   @default(PROD)
    status           RunStatus @default(QUEUED)
    inputText        String    @db.Text
    outputText       String?   @db.Text
    durationMs       Int?
    startedAt        DateTime  @default(now())
    completedAt      DateTime?
    modelProvider    String?
    modelName        String?
    versionId        String?
    promptTokens     Int?
    completionTokens Int?
    totalTokens      Int?
    costUsd          Float?
    userId           String?
    createdAt        DateTime  @default(now())

    // Conversation turn tracking (One Run = One Conversation)
    // For chat: turnCount > 0, tokens/cost are aggregates across turns
    // For non-chat (Slack, Voice, etc.): turnCount = 0, legacy single-message run
    turnCount Int @default(0)

    // Continuous Learning: Experiment linkage for shadow A/B testing
    experimentId    String? // Links run to active experiment for A/B testing
    experiment      LearningExperiment? @relation(fields: [experimentId], references: [id], onDelete: SetNull)
    experimentGroup String? // "baseline" or "candidate" - which version this run used

    // Skills active at run time [{skillId, skillSlug, skillVersion}]
    skillsJson Json?

    // Failure classification for budget/guardrail/error reporting
    failureReason String? // "BUDGET_EXCEEDED", "GUARDRAIL_BLOCKED", "EXECUTION_ERROR", etc.

    // Production channel tracking
    source      String? // "slack", "whatsapp", "voice", "telegram", "elevenlabs", "api", "test"
    triggerType RunTriggerType @default(API)
    triggerId   String?
    sessionId   String? // Channel session ID for conversation grouping
    threadId    String? // Thread/conversation ID within a channel

    // Relations
    turns           AgentRunTurn[]
    trace           AgentTrace?
    toolCalls       AgentToolCall[]
    workflowSteps   WorkflowRunStep[]
    evaluation      AgentEvaluation?
    feedbacks       AgentFeedback[]
    costEvents      CostEvent[]
    guardrailEvents GuardrailEvent[]
    conversation    AgentConversation?
    testRun         AgentTestRun?
    TriggerEvent    TriggerEvent?
    missionTask     MissionTask?

    @@index([agentId, createdAt])
    @@index([status])
    @@index([tenantId])
    @@index([experimentId])
    @@index([source])
    @@index([sessionId])
    @@index([threadId])
    @@index([source, userId, createdAt]) // Rate limiting: per-user per-source
    @@index([source, threadId, createdAt]) // Rate limiting: per-org per-source via threadId prefix
    @@map("agent_run")
}

// Agent Run Turn - Individual message round-trips within a conversation run
model AgentRunTurn {
    id               String    @id @default(cuid())
    runId            String
    run              AgentRun  @relation(fields: [runId], references: [id], onDelete: Cascade)
    turnIndex        Int // 0-based order within the conversation
    inputText        String    @db.Text
    outputText       String?   @db.Text
    durationMs       Int?
    startedAt        DateTime  @default(now())
    completedAt      DateTime?
    promptTokens     Int?
    completionTokens Int?
    totalTokens      Int?
    costUsd          Float?
    modelProvider    String?
    modelName        String?
    stepsJson        Json? // Execution steps for this turn
    createdAt        DateTime  @default(now())

    // Relations
    toolCalls  AgentToolCall[]
    costEvents CostEvent[]
    feedbacks  AgentFeedback[]

    @@unique([runId, turnIndex])
    @@index([runId, turnIndex])
    @@map("agent_run_turn")
}

// Agent Trace - Detailed execution trace per run
model AgentTrace {
    id                   String    @id @default(cuid())
    runId                String    @unique
    run                  AgentRun  @relation(fields: [runId], references: [id], onDelete: Cascade)
    agentId              String
    agent                Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId             String?
    status               RunStatus @default(RUNNING)
    inputText            String    @db.Text
    outputText           String?   @db.Text
    durationMs           Int?
    stepsJson            Json? // Array of execution steps
    modelJson            Json? // Model configuration used
    tokensJson           Json? // Token counts
    scoresJson           Json? // Evaluation scores
    instructionsHash     String? // SHA-256 of merged instructions (base + skills)
    instructionsSnapshot String?   @db.Text // Full merged instructions for audit
    createdAt            DateTime  @default(now())

    // Relations
    steps     AgentTraceStep[]
    toolCalls AgentToolCall[]

    @@index([runId])
    @@index([agentId, createdAt])
    @@index([tenantId])
    @@map("agent_trace")
}

// Agent Trace Step - Individual execution steps
model AgentTraceStep {
    id         String     @id @default(cuid())
    traceId    String
    trace      AgentTrace @relation(fields: [traceId], references: [id], onDelete: Cascade)
    tenantId   String?
    stepNumber Int
    type       String // "llm" | "tool" | "memory" | "guardrail"
    content    Json // Step-specific content
    timestamp  DateTime   @default(now())
    durationMs Int?

    @@index([traceId, stepNumber])
    @@index([tenantId])
    @@map("agent_trace_step")
}

// Agent Tool Call - Tool call records
model AgentToolCall {
    id          String        @id @default(cuid())
    runId       String?
    run         AgentRun?     @relation(fields: [runId], references: [id], onDelete: Cascade)
    traceId     String?
    trace       AgentTrace?   @relation(fields: [traceId], references: [id], onDelete: Cascade)
    turnId      String?
    turn        AgentRunTurn? @relation(fields: [turnId], references: [id], onDelete: Cascade)
    tenantId    String?
    toolKey     String
    mcpServerId String?
    toolSource  String? // "registry", "mcp:hubspot", "skill:research-assistant"
    inputJson   Json?
    outputJson  Json?
    success     Boolean       @default(true)
    error       String?       @db.Text
    durationMs  Int?
    createdAt   DateTime      @default(now())

    @@index([runId])
    @@index([turnId])
    @@index([traceId, toolKey])
    @@index([toolKey, runId]) // Enables fast lookup for Slack feedback detection
    @@index([tenantId])
    @@map("agent_tool_call")
}

// Agent Alert - System/budget/guardrail alerts
model AgentAlert {
    id         String        @id @default(cuid())
    agentId    String
    agent      Agent         @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId   String?
    severity   AlertSeverity @default(INFO)
    message    String        @db.Text
    source     AlertSource   @default(SYSTEM)
    createdAt  DateTime      @default(now())
    resolvedAt DateTime?

    @@index([agentId, createdAt, severity])
    @@index([tenantId])
    @@map("agent_alert")
}

// Audit Log - All write operations
model AuditLog {
    id         String   @id @default(cuid())
    tenantId   String?
    actorId    String? // User ID who performed the action
    action     String // AGENT_CREATE, AGENT_UPDATE, CONFIG_CHANGE, etc.
    entityType String // Agent, AgentVersion, etc.
    entityId   String
    metadata   Json? // Additional context
    createdAt  DateTime @default(now())

    @@index([tenantId, createdAt])
    @@index([entityId])
    @@map("audit_log")
}

// Agent Evaluation - Evaluation scores per run
model AgentEvaluation {
    id            String   @id @default(cuid())
    runId         String   @unique
    run           AgentRun @relation(fields: [runId], references: [id], onDelete: Cascade)
    agentId       String
    agent         Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId      String?
    scoresJson    Json // {criterion_id: score} or legacy {relevancy: 0.9, ...}
    scorerVersion String?

    // AI Auditor fields
    feedbackJson      Json? // {criterion_id: "written feedback per criterion"}
    overallGrade      Float? // Weighted overall score from scorecard criteria
    narrative         String? @db.Text // Overall written assessment from auditor
    auditorModel      String? // Which model performed the evaluation (e.g., "gpt-4o-mini")
    traceContextJson  Json? // Summary of what was evaluated (tool count, step count, etc.)
    scorecardVersion  Int? // Which version of the scorecard was used
    evaluationTier    String? // "tier1_heuristic" | "tier2_auditor"
    confidenceScore   Float? // Auditor's self-assessed confidence (0-1)
    groundTruthUsed   Boolean @default(false) // Whether expectedOutput was compared
    skillAttributions Json? // {skillSlug: {impact, note}} per active skill
    turnEvaluations   Json? // For conversations: [{turnIndex, scores, feedback}]

    // AAR (After Action Review) structured output
    aarJson Json? // {what_should_have_happened, what_actually_happened, why_difference, sustain[], improve[]}

    // Re-evaluation support (feedback-triggered)
    reEvaluatedAt      DateTime? // When this evaluation was re-assessed with human feedback
    previousScoresJson Json? // Snapshot of scores before re-evaluation
    rawScoresJson      Json? // Original Tier 1 heuristic scores (before normalization to scorecard criteria)

    createdAt DateTime @default(now())

    // Relations
    calibrationChecks CalibrationCheck[]
    recommendations   AgentRecommendation[]

    @@index([runId])
    @@index([agentId, createdAt])
    @@index([tenantId])
    @@index([evaluationTier])
    @@map("agent_evaluation")
}

// Agent Feedback - User feedback per turn or per conversation
model AgentFeedback {
    id        String        @id @default(cuid())
    runId     String
    run       AgentRun      @relation(fields: [runId], references: [id], onDelete: Cascade)
    turnId    String?
    turn      AgentRunTurn? @relation(fields: [turnId], references: [id], onDelete: Cascade)
    agentId   String
    agent     Agent         @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId  String?
    thumbs    Boolean? // true = up, false = down
    rating    Int? // 1-5 scale
    comment   String?       @db.Text
    source    String? // "slack" | "ui" | "api" | "voice" | "whatsapp"
    createdAt DateTime      @default(now())

    @@index([runId])
    @@index([turnId])
    @@index([agentId])
    @@index([tenantId])
    @@map("agent_feedback")
}

// Agent Test Case - Stored test cases
model AgentTestCase {
    id             String   @id @default(cuid())
    agentId        String
    agent          Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId       String?
    name           String
    inputText      String   @db.Text
    expectedOutput String?  @db.Text
    tags           String[] @default([])
    createdBy      String?
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    // Relations
    testRuns AgentTestRun[]

    @@index([agentId])
    @@index([tenantId])
    @@map("agent_test_case")
}

// Agent Test Run - Test execution results
model AgentTestRun {
    id         String        @id @default(cuid())
    testCaseId String
    testCase   AgentTestCase @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
    agentId    String
    agent      Agent         @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId   String?
    versionId  String?
    runId      String?       @unique
    run        AgentRun?     @relation(fields: [runId], references: [id], onDelete: SetNull)
    outputText String?       @db.Text
    passed     Boolean?
    score      Float?
    durationMs Int?
    tokens     Int?
    createdAt  DateTime      @default(now())

    @@index([testCaseId])
    @@index([agentId])
    @@index([tenantId])
    @@map("agent_test_run")
}

// Agent Conversation - Multi-turn conversation persistence
model AgentConversation {
    id           String    @id @default(cuid())
    agentId      String
    agent        Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId     String?
    runId        String?   @unique
    run          AgentRun? @relation(fields: [runId], references: [id], onDelete: SetNull)
    messagesJson Json // Array of {role, content, timestamp}
    createdAt    DateTime  @default(now())

    @@index([agentId])
    @@index([tenantId])
    @@map("agent_conversation")
}

// Budget Policy - Per-agent budget settings
model BudgetPolicy {
    id              String    @id @default(cuid())
    agentId         String?   @unique
    agent           Agent?    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    workflowId      String?   @unique
    workflow        Workflow? @relation(fields: [workflowId], references: [id], onDelete: Cascade)
    networkId       String?   @unique
    network         Network?  @relation(fields: [networkId], references: [id], onDelete: Cascade)
    tenantId        String?
    enabled         Boolean   @default(false)
    monthlyLimitUsd Float?
    alertAtPct      Float?    @default(80) // Alert when usage reaches this percentage
    hardLimit       Boolean   @default(true) // Block runs when limit exceeded
    createdAt       DateTime  @default(now())
    updatedAt       DateTime  @updatedAt

    @@index([agentId])
    @@index([workflowId])
    @@index([networkId])
    @@index([tenantId])
    @@map("budget_policy")
}

// Cost Event - Token/cost tracking per run
model CostEvent {
    id               String        @id @default(cuid())
    runId            String
    run              AgentRun      @relation(fields: [runId], references: [id], onDelete: Cascade)
    turnId           String?
    turn             AgentRunTurn? @relation(fields: [turnId], references: [id], onDelete: Cascade)
    agentId          String
    agent            Agent         @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId         String?
    userId           String?
    provider         String
    modelName        String
    promptTokens     Int?
    completionTokens Int?
    totalTokens      Int?
    costUsd          Float?
    platformCostUsd  Float?
    billedCostUsd    Float?
    markupMultiplier Float?
    createdAt        DateTime      @default(now())

    @@index([runId])
    @@index([turnId])
    @@index([agentId, createdAt])
    @@index([tenantId])
    @@index([userId, createdAt])
    @@map("cost_event")
}

// Agent Cost Daily - Daily cost rollups
model AgentCostDaily {
    id                String   @id @default(cuid())
    agentId           String
    agent             Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId          String?
    date              DateTime @db.Date
    totalCostUsd      Float    @default(0)
    promptCostUsd     Float    @default(0)
    completionCostUsd Float    @default(0)
    runs              Int      @default(0)

    @@unique([agentId, date])
    @@index([agentId, date])
    @@index([tenantId])
    @@map("agent_cost_daily")
}

// Agent Model Cost Daily - Cost by model per day
model AgentModelCostDaily {
    id        String   @id @default(cuid())
    agentId   String
    agent     Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId  String?
    modelName String
    date      DateTime @db.Date
    costUsd   Float    @default(0)
    tokens    Int      @default(0)
    runs      Int      @default(0)

    @@unique([agentId, modelName, date])
    @@index([agentId, modelName, date])
    @@index([tenantId])
    @@map("agent_model_cost_daily")
}

// Cost Recommendation - AI-generated savings tips
model CostRecommendation {
    id                  String   @id @default(cuid())
    agentId             String
    agent               Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId            String?
    type                String // "model_switch", "prompt_optimization", etc.
    title               String
    description         String   @db.Text
    estimatedSavingsUsd Float?
    createdAt           DateTime @default(now())

    @@index([agentId, createdAt])
    @@index([tenantId])
    @@map("cost_recommendation")
}

// Guardrail Policy - Per-agent guardrail config
model GuardrailPolicy {
    id         String   @id @default(cuid())
    agentId    String   @unique
    agent      Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId   String?
    configJson Json // Full guardrail configuration
    version    Int      @default(1)
    createdBy  String?
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    @@index([agentId])
    @@index([tenantId])
    @@map("guardrail_policy")
}

// Guardrail Event - Blocked/modified/flagged events
model GuardrailEvent {
    id            String             @id @default(cuid())
    agentId       String
    agent         Agent              @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId      String?
    runId         String?
    run           AgentRun?          @relation(fields: [runId], references: [id], onDelete: SetNull)
    type          GuardrailEventType
    guardrailKey  String
    reason        String             @db.Text
    inputSnippet  String?            @db.Text
    outputSnippet String?            @db.Text
    createdAt     DateTime           @default(now())

    @@index([agentId, createdAt])
    @@index([tenantId])
    @@map("guardrail_event")
}

// Org-wide Guardrail Policy - Organization-level guardrail baseline
model OrgGuardrailPolicy {
    id             String       @id @default(cuid())
    organizationId String       @unique
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    configJson     Json
    version        Int          @default(1)
    createdBy      String?
    createdAt      DateTime     @default(now())
    updatedAt      DateTime     @updatedAt

    @@index([organizationId])
    @@map("org_guardrail_policy")
}

// Agent Stats Daily - Daily KPI rollups
model AgentStatsDaily {
    id              String   @id @default(cuid())
    agentId         String
    agent           Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId        String?
    date            DateTime @db.Date
    totalRuns       Int      @default(0)
    successRate     Float?
    avgDurationMs   Float?
    avgQualityScore Float?
    totalCostUsd    Float    @default(0)

    @@unique([agentId, date])
    @@index([agentId, date])
    @@index([tenantId])
    @@map("agent_stats_daily")
}

// Agent Metric Daily - Performance metrics
model AgentMetricDaily {
    id           String   @id @default(cuid())
    agentId      String
    agent        Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId     String?
    date         DateTime @db.Date
    runs         Int      @default(0)
    successRate  Float?
    avgLatencyMs Float?
    errorRate    Float?
    qualityScore Float?

    @@unique([agentId, date])
    @@index([agentId, date])
    @@index([tenantId])
    @@map("agent_metric_daily")
}

// Agent Tool Metric Daily - Tool usage metrics
model AgentToolMetricDaily {
    id            String   @id @default(cuid())
    agentId       String
    agent         Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId      String?
    toolKey       String
    date          DateTime @db.Date
    callCount     Int      @default(0)
    successRate   Float?
    avgDurationMs Float?

    @@unique([agentId, toolKey, date])
    @@index([agentId, toolKey, date])
    @@index([tenantId])
    @@map("agent_tool_metric_daily")
}

// Agent Model Metric Daily - Model comparison metrics
model AgentModelMetricDaily {
    id            String   @id @default(cuid())
    agentId       String
    agent         Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId      String?
    modelProvider String
    modelName     String
    date          DateTime @db.Date
    runs          Int      @default(0)
    avgLatencyMs  Float?
    qualityScore  Float?
    costUsd       Float    @default(0)

    @@unique([agentId, modelName, date])
    @@index([agentId, modelName, date])
    @@index([tenantId])
    @@map("agent_model_metric_daily")
}

// Agent Quality Metric Daily - Quality score rollups
model AgentQualityMetricDaily {
    id          String   @id @default(cuid())
    agentId     String
    agent       Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId    String?
    scorerKey   String
    date        DateTime @db.Date
    avgScore    Float?
    sampleCount Int      @default(0)

    @@unique([agentId, scorerKey, date])
    @@index([agentId, scorerKey, date])
    @@index([tenantId])
    @@map("agent_quality_metric_daily")
}

// Agent Health Score - Composite daily health metric per agent
model AgentHealthScore {
    id       String   @id @default(cuid())
    agentId  String
    agent    Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId String?
    date     DateTime @db.Date

    // Composite components (0.0-1.0)
    evalScore            Float // Weighted avg of last N eval scores
    feedbackScore        Float // Positive feedback ratio
    toolSuccessRate      Float // Tool call success rate
    improvementVelocity  Float // Score trend direction
    recommendationHealth Float // Ratio of graduated vs active recs

    // Composite health (weighted combination)
    healthScore  Float // The single number: 0.0-1.0
    healthStatus String // "excellent" | "good" | "fair" | "poor" | "critical"
    confidence   Float  @default(0.0) // 0.0-1.0: how much data backs this score

    // Context
    runCount      Int // Runs in this period
    evalCount     Int // Evaluations in this period
    feedbackCount Int // Feedback items in this period

    createdAt DateTime @default(now())

    @@unique([agentId, date])
    @@index([agentId, date])
    @@index([tenantId])
    @@map("agent_health_score")
}

// Agent Feedback Aggregate Daily - Feedback summaries
model AgentFeedbackAggregateDaily {
    id            String   @id @default(cuid())
    agentId       String
    agent         Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId      String?
    date          DateTime @db.Date
    positiveCount Int      @default(0)
    negativeCount Int      @default(0)

    @@unique([agentId, date])
    @@index([agentId, date])
    @@index([tenantId])
    @@map("agent_feedback_aggregate_daily")
}

// Agent Version Stats - Per-version performance
model AgentVersionStats {
    id          String       @id @default(cuid())
    versionId   String
    version     AgentVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)
    agentId     String
    agent       Agent        @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId    String?
    runs        Int          @default(0)
    successRate Float?
    avgQuality  Float?
    updatedAt   DateTime     @updatedAt

    @@unique([versionId])
    @@index([versionId])
    @@index([tenantId])
    @@map("agent_version_stats")
}

// Evaluation Theme - Feedback theme extraction
model EvaluationTheme {
    id        String   @id @default(cuid())
    agentId   String
    agent     Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId  String?
    theme     String
    sentiment String? // "positive", "negative", "neutral"
    count     Int      @default(0)
    createdAt DateTime @default(now())

    @@index([agentId, createdAt])
    @@index([tenantId])
    @@map("evaluation_theme")
}

// Insight - AI-generated insights
model Insight {
    id          String  @id @default(cuid())
    agentId     String
    agent       Agent   @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId    String?
    type        String // "performance", "cost", "quality", "warning", "info"
    title       String
    description String  @db.Text

    // Action pipeline (insights can trigger downstream events)
    actionType   String? @default("informational") // "learning_trigger" | "alert" | "scorecard_adjustment" | "informational"
    actionStatus String  @default("pending") // "pending" | "executed" | "dismissed"
    actionRef    String? // ID of learning session, alert, etc. created by the action

    createdAt DateTime @default(now())

    @@index([agentId, createdAt])
    @@index([tenantId])
    @@map("insight")
}

// ==============================
// Closed-Loop Learning Models
// ==============================

// Learning Session Status Enum
enum LearningSessionStatus {
    COLLECTING // Gathering runs for analysis
    ANALYZING // Extracting signals from runs
    PROPOSING // Generating improvement proposals
    TESTING // Running A/B experiments
    AWAITING_APPROVAL // Waiting for human approval
    APPROVED // Approved and promoting
    REJECTED // Rejected by human
    PROMOTED // Successfully promoted new version
    FAILED // Failed during processing
}

// Learning Experiment Status Enum
enum LearningExperimentStatus {
    PENDING // Not started
    RUNNING // A/B test in progress
    COMPLETED // Test finished
    PASSED // Candidate beat baseline
    FAILED // Candidate did not beat baseline
}

// Learning Signal Type Enum
enum LearningSignalType {
    LOW_SCORE // Run scored below threshold
    TOOL_FAILURE // Tool call failed
    GUARDRAIL_HIT // Guardrail triggered
    NEGATIVE_FEEDBACK // User gave negative feedback
    HIGH_LATENCY // Run took too long
    ERROR // Run failed with error
    PATTERN // Detected pattern across runs
    SKILL_CORRELATION // Skill correlated with poor performance
    NARRATIVE_PATTERN // Recurring pattern extracted from AI auditor narratives
}

// Risk Tier Enum for Continuous Learning
enum RiskTier {
    LOW // Safe for auto-promotion (instruction-only edits)
    MEDIUM // Requires review but not high-risk
    HIGH // Requires human approval (model/tool/memory changes)
}

// Learning Session - Orchestrates each closed-loop learning cycle
model LearningSession {
    id              String                @id @default(cuid())
    agentId         String
    agent           Agent                 @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId        String?
    status          LearningSessionStatus @default(COLLECTING)
    runCount        Int                   @default(0) // Number of runs analyzed
    datasetHash     String? // SHA256 hash of run IDs for provenance
    baselineVersion Int? // Agent version at start
    scorerConfig    Json? // Scorer configuration used
    thresholdsJson  Json? // Gating thresholds for A/B test
    metadata        Json? // Additional context
    createdBy       String?
    createdAt       DateTime              @default(now())
    updatedAt       DateTime              @updatedAt
    completedAt     DateTime?

    // Relations
    dataset     LearningDataset?
    signals     LearningSignal[]
    proposals   LearningProposal[]
    experiments LearningExperiment[]
    approval    LearningApproval?

    @@index([agentId, createdAt])
    @@index([tenantId])
    @@index([status])
    @@map("learning_session")
}

// Learning Dataset - Snapshot of runs used for learning
model LearningDataset {
    id                String          @id @default(cuid())
    sessionId         String          @unique
    session           LearningSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
    tenantId          String?
    runIds            String[] // Array of AgentRun IDs included
    selectionCriteria Json? // Criteria used to select runs
    datasetHash       String // SHA256 hash for reproducibility
    fromDate          DateTime? // Start of time range
    toDate            DateTime? // End of time range
    runCount          Int             @default(0)
    avgScore          Float? // Average quality score
    createdAt         DateTime        @default(now())

    @@index([sessionId])
    @@index([tenantId])
    @@index([datasetHash])
    @@map("learning_dataset")
}

// Learning Signal - Extracted patterns from runs
model LearningSignal {
    id           String             @id @default(cuid())
    sessionId    String
    session      LearningSession    @relation(fields: [sessionId], references: [id], onDelete: Cascade)
    tenantId     String?
    type         LearningSignalType
    severity     String? // "low", "medium", "high"
    pattern      String             @db.Text // Description of the pattern
    evidenceJson Json? // Run IDs and specific examples
    frequency    Int                @default(1) // How often this occurred
    impact       Float? // Estimated impact score
    createdAt    DateTime           @default(now())

    @@index([sessionId])
    @@index([tenantId])
    @@index([type])
    @@map("learning_signal")
}

// Learning Proposal - Proposed changes to improve agent
model LearningProposal {
    id                 String          @id @default(cuid())
    sessionId          String
    session            LearningSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
    tenantId           String?
    proposalType       String // "instructions", "tools", "memory", "model", "combined"
    title              String
    description        String          @db.Text
    instructionsDiff   String?         @db.Text // Unified diff of instructions change
    toolChangesJson    Json? // {added: [], removed: [], modified: []}
    memoryChangesJson  Json? // Changes to memory config
    modelChangesJson   Json? // Changes to model config
    expectedImpact     String?         @db.Text // Expected improvement
    confidenceScore    Float? // 0-1 confidence in proposal
    generatedBy        String? // "llm", "heuristic", "human"
    candidateVersionId String? // Created AgentVersion ID if built
    isSelected         Boolean         @default(false) // Selected for testing
    createdAt          DateTime        @default(now())

    // Continuous Learning: Risk assessment fields
    riskTier     RiskTier? // LOW, MEDIUM, HIGH - determines auto-promotion eligibility
    autoEligible Boolean   @default(false) // Whether this can be auto-promoted
    riskReasons  Json? // Array of reasons for risk classification

    // Relations
    experiments LearningExperiment[]

    @@index([sessionId])
    @@index([tenantId])
    @@index([riskTier])
    @@map("learning_proposal")
}

// Learning Experiment - A/B test configuration and results
model LearningExperiment {
    id                 String                   @id @default(cuid())
    sessionId          String
    session            LearningSession          @relation(fields: [sessionId], references: [id], onDelete: Cascade)
    proposalId         String
    proposal           LearningProposal         @relation(fields: [proposalId], references: [id], onDelete: Cascade)
    tenantId           String?
    status             LearningExperimentStatus @default(PENDING)
    baselineVersionId  String? // Current agent version
    candidateVersionId String? // New version to test
    testCaseIds        String[] // Test cases used
    syntheticTestCount Int                      @default(0) // Generated test count
    baselineMetrics    Json? // {avgScore, successRate, latency, etc.}
    candidateMetrics   Json? // Same structure as baseline
    gatingThreshold    Float                    @default(0.5) // Win rate needed
    winRate            Float? // Candidate win rate
    confidenceInterval Json? // {lower, upper}
    gatingResult       String? // "passed", "failed", "inconclusive"
    startedAt          DateTime?
    completedAt        DateTime?
    createdAt          DateTime                 @default(now())

    // Continuous Learning: Real-traffic shadow testing fields
    trafficSplit      Json? // {baseline: 0.9, candidate: 0.1} - traffic allocation
    shadowRunCount    Int   @default(0) // Total runs in shadow test
    baselineRunCount  Int   @default(0) // Runs routed to baseline
    candidateRunCount Int   @default(0) // Runs routed to candidate

    // Relations
    runs AgentRun[] // Runs tagged to this experiment

    @@index([sessionId])
    @@index([proposalId])
    @@index([tenantId])
    @@index([status])
    @@map("learning_experiment")
}

// Learning Approval - Human or auto decision on proposals
model LearningApproval {
    id                String          @id @default(cuid())
    sessionId         String          @unique
    session           LearningSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
    tenantId          String?
    decision          String // "approved", "rejected", "deferred", "auto_approved"
    rationale         String?         @db.Text
    approvedBy        String? // User ID (null for auto-approval)
    promotedVersionId String? // New AgentVersion ID if promoted
    reviewedAt        DateTime?
    createdAt         DateTime        @default(now())

    // Continuous Learning: Auto-promotion tracking
    autoApproved Boolean @default(false) // Whether this was auto-approved

    @@index([sessionId])
    @@index([tenantId])
    @@index([autoApproved])
    @@map("learning_approval")
}

// Learning Policy - Per-agent continuous learning configuration
model LearningPolicy {
    id                   String    @id @default(cuid())
    agentId              String    @unique
    agent                Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId             String?
    enabled              Boolean   @default(true) // Master switch for continuous learning
    autoPromotionEnabled Boolean   @default(false) // Allow auto-promotion for low-risk changes
    scheduledEnabled     Boolean   @default(true) // Enable scheduled backstop triggers
    thresholdEnabled     Boolean   @default(true) // Enable signal threshold triggers
    paused               Boolean   @default(false) // Temporarily pause learning
    pausedUntil          DateTime? // Auto-resume after this time

    // Thresholds and configuration (can override global defaults)
    signalThreshold       Int? // Signals needed to trigger session
    signalWindowMinutes   Int? // Time window for signal accumulation
    trafficSplitCandidate Float? // Default candidate traffic split (e.g., 0.1 = 10%)
    minConfidenceForAuto  Float? // Minimum confidence score for auto-promotion
    minWinRateForAuto     Float? // Minimum win rate for auto-promotion

    // Audit
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    updatedBy String?

    @@index([agentId])
    @@index([tenantId])
    @@map("learning_policy")
}

// Learning Metric Daily - Daily closed-loop learning KPIs
model LearningMetricDaily {
    id                 String   @id @default(cuid())
    agentId            String
    agent              Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId           String?
    date               DateTime @db.Date
    sessionsStarted    Int      @default(0)
    sessionsCompleted  Int      @default(0)
    proposalsGenerated Int      @default(0)
    proposalsApproved  Int      @default(0)
    proposalsRejected  Int      @default(0)
    experimentsRun     Int      @default(0)
    experimentsPassed  Int      @default(0)
    versionsPromoted   Int      @default(0)
    avgImprovementPct  Float? // Average quality improvement
    evalCoverage       Float? // Percentage of runs evaluated

    // Continuous Learning: Auto vs Manual tracking
    autoPromotions    Int @default(0) // Promotions via auto-approval
    manualPromotions  Int @default(0) // Promotions via human approval
    shadowRunCount    Int @default(0) // Runs in shadow A/B tests
    baselineRunCount  Int @default(0) // Runs routed to baseline
    candidateRunCount Int @default(0) // Runs routed to candidate
    regressionCount   Int @default(0) // Guardrail regressions detected
    scheduledTriggers Int @default(0) // Sessions started via schedule
    thresholdTriggers Int @default(0) // Sessions started via signal threshold

    @@unique([agentId, date])
    @@index([agentId, date])
    @@index([tenantId])
    @@map("learning_metric_daily")
}

// ==============================
// Simulation System Models
// ==============================

// Simulation Session - Tracks a batch of simulated conversations for testing agents
model SimulationSession {
    id      String @id @default(cuid())
    agentId String
    agent   Agent  @relation(fields: [agentId], references: [id], onDelete: Cascade)
    theme   String @db.Text // "Customer service about timesheets"
    status  String @default("PENDING") // PENDING, RUNNING, COMPLETED, FAILED, CANCELLED

    // Configuration
    targetCount Int @default(100)
    concurrency Int @default(5)

    // Progress
    completedCount Int @default(0)
    failedCount    Int @default(0)

    // Results (computed when complete)
    avgQualityScore Float?
    avgDurationMs   Float?
    successRate     Float?
    totalCostUsd    Float?

    // Safety metrics (red-team simulations)
    safetyScore     Float?
    safetyPassCount Int    @default(0)
    safetyFailCount Int    @default(0)

    // Timing
    startedAt   DateTime?
    completedAt DateTime?
    createdAt   DateTime  @default(now())

    @@index([agentId, createdAt])
    @@index([status])
    @@map("simulation_session")
}

// ==============================
// Workflow + Network Workspace Models
// ==============================

// Workflow Definition
model Workflow {
    id          String  @id @default(cuid())
    slug        String  @unique
    name        String
    description String? @db.Text

    // Visual definition (React Flow compatible)
    definitionJson Json // { nodes: [], edges: [], viewport: {} }

    // Compiled representation (cached)
    compiledJson Json?
    compiledAt   DateTime?
    compiledHash String?

    // Schemas
    inputSchemaJson  Json?
    outputSchemaJson Json?

    // Configuration
    maxSteps    Int   @default(50)
    timeout     Int?
    retryConfig Json?

    // Status
    isPublished Boolean @default(false)
    isActive    Boolean @default(true)
    version     Int     @default(1)

    // Tenancy
    workspaceId String?
    workspace   Workspace?   @relation(fields: [workspaceId], references: [id])
    ownerId     String?
    type        WorkflowType @default(USER)

    // Audit
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    createdBy String?

    // Relations
    versions          WorkflowVersion[]
    runs              WorkflowRun[]
    networkPrimitives NetworkPrimitive[]
    metrics           WorkflowMetricDaily[]
    triggerEvents     TriggerEvent[]
    budgetPolicy      BudgetPolicy?
    testCases         WorkflowTestCase[]

    @@index([slug])
    @@index([workspaceId])
    @@index([isPublished])
    @@map("workflow")
}

// Workflow Version History
model WorkflowVersion {
    id             String   @id @default(cuid())
    workflowId     String
    workflow       Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
    version        Int
    definitionJson Json
    description    String?  @db.Text
    createdAt      DateTime @default(now())
    createdBy      String?

    @@unique([workflowId, version])
    @@index([workflowId])
    @@map("workflow_version")
}

// Workflow Execution
model WorkflowRun {
    id         String    @id @default(cuid())
    workflowId String
    workflow   Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)
    status     RunStatus @default(QUEUED)

    // Input/Output
    inputJson  Json
    outputJson Json?

    // Suspension (human-in-the-loop)
    suspendedAt     DateTime?
    suspendedStep   String?
    suspendDataJson Json?
    resumedAt       DateTime?
    resumeDataJson  Json?

    // Execution stats
    durationMs  Int?
    startedAt   DateTime  @default(now())
    completedAt DateTime?
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt

    // Cost tracking
    totalTokens  Int?
    totalCostUsd Float?

    // Version tracking
    versionId String?

    // Source tracking
    source       String?
    environment  RunEnvironment @default(DEVELOPMENT)
    triggerType  RunTriggerType @default(API)
    triggerId    String?
    networkRunId String?
    networkRun   NetworkRun?    @relation(fields: [networkRunId], references: [id])

    // Relations
    steps           WorkflowRunStep[]
    ApprovalRequest ApprovalRequest[]
    TriggerEvent    TriggerEvent?
    evaluation      WorkflowRunEvaluation?
    feedback        WorkflowRunFeedback[]

    @@index([workflowId, createdAt])
    @@index([workflowId, environment])
    @@index([workflowId, triggerType])
    @@index([status])
    @@map("workflow_run")
}

// Workflow Run Evaluation
model WorkflowRunEvaluation {
    id            String      @id @default(cuid())
    workflowRunId String      @unique
    workflowRun   WorkflowRun @relation(fields: [workflowRunId], references: [id], onDelete: Cascade)
    workflowId    String

    // Scores
    stepSuccessRate Float? // Fraction of steps that completed (0.0 - 1.0)
    outputQuality   Float? // LLM-assessed quality of final output (0.0 - 1.0)
    durationScore   Float? // Normalized duration score (0.0 - 1.0)
    overallScore    Float? // Weighted composite score

    // Details
    stepScores Json? // {stepId: {status, durationMs, score}}
    narrative  String? @db.Text // LLM narrative of evaluation

    createdAt DateTime @default(now())

    @@index([workflowId])
    @@map("workflow_run_evaluation")
}

// Workflow Step Execution
model WorkflowRunStep {
    id    String      @id @default(cuid())
    runId String
    run   WorkflowRun @relation(fields: [runId], references: [id], onDelete: Cascade)

    stepId   String
    stepType String
    stepName String?

    status     RunStatus @default(QUEUED)
    inputJson  Json?
    outputJson Json?
    errorJson  Json?

    // For loops
    iterationIndex Int?

    // Timing
    startedAt   DateTime?
    completedAt DateTime?
    durationMs  Int?

    // Nested execution
    agentRunId String?
    agentRun   AgentRun? @relation(fields: [agentRunId], references: [id], onDelete: SetNull)

    @@index([runId])
    @@index([stepId])
    @@map("workflow_run_step")
}

// Network Definition
model Network {
    id          String  @id @default(cuid())
    slug        String  @unique
    name        String
    description String? @db.Text

    // Routing agent configuration
    instructions  String @db.Text
    modelProvider String
    modelName     String
    temperature   Float? @default(0.7)

    // Visual topology
    topologyJson Json

    // Memory configuration (required for networks)
    memoryConfig Json

    // Execution settings
    maxSteps Int @default(10)

    // Status
    isPublished Boolean @default(false)
    isActive    Boolean @default(true)
    version     Int     @default(1)

    // Tenancy
    workspaceId String?
    workspace   Workspace?  @relation(fields: [workspaceId], references: [id])
    ownerId     String?
    type        NetworkType @default(USER)

    // Audit
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    createdBy String?

    // Relations
    primitives    NetworkPrimitive[]
    versions      NetworkVersion[]
    runs          NetworkRun[]
    metrics       NetworkMetricDaily[]
    triggerEvents TriggerEvent[]
    budgetPolicy  BudgetPolicy?
    testCases     NetworkTestCase[]

    @@index([slug])
    @@index([workspaceId])
    @@index([isPublished])
    @@map("network")
}

// Network Primitive Junction
model NetworkPrimitive {
    id        String  @id @default(cuid())
    networkId String
    network   Network @relation(fields: [networkId], references: [id], onDelete: Cascade)

    primitiveType String // "agent", "workflow", "tool"

    // Reference (one of these will be set)
    agentId    String?
    agent      Agent?    @relation(fields: [agentId], references: [id], onDelete: Cascade)
    workflowId String?
    workflow   Workflow? @relation(fields: [workflowId], references: [id], onDelete: Cascade)
    toolId     String?

    // Override description for routing
    description String? @db.Text

    // Position in visual topology
    position Json?

    createdAt DateTime @default(now())

    @@unique([networkId, agentId])
    @@unique([networkId, workflowId])
    @@unique([networkId, toolId])
    @@index([networkId])
    @@map("network_primitive")
}

// Network Version History
model NetworkVersion {
    id             String   @id @default(cuid())
    networkId      String
    network        Network  @relation(fields: [networkId], references: [id], onDelete: Cascade)
    version        Int
    topologyJson   Json
    primitivesJson Json
    description    String?  @db.Text
    createdAt      DateTime @default(now())
    createdBy      String?

    @@unique([networkId, version])
    @@index([networkId])
    @@map("network_version")
}

// Network Execution
model NetworkRun {
    id        String    @id @default(cuid())
    networkId String
    network   Network   @relation(fields: [networkId], references: [id], onDelete: Cascade)
    status    RunStatus @default(QUEUED)

    // Input/Output
    inputText  String  @db.Text
    outputText String? @db.Text
    outputJson Json?

    // Thread/Memory
    threadId   String?
    resourceId String?

    // Stats
    stepsExecuted Int?
    durationMs    Int?
    startedAt     DateTime  @default(now())
    completedAt   DateTime?
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt

    // Token usage
    totalTokens  Int?
    totalCostUsd Float?

    // Version tracking
    versionId String?

    // Source
    source      String?
    environment RunEnvironment @default(DEVELOPMENT)
    triggerType RunTriggerType @default(API)

    // Relations
    steps        NetworkRunStep[]
    workflowRuns WorkflowRun[]
    TriggerEvent TriggerEvent?
    evaluation   NetworkRunEvaluation?
    feedback     NetworkRunFeedback[]

    @@index([networkId, createdAt])
    @@index([networkId, environment])
    @@index([networkId, triggerType])
    @@index([status])
    @@index([threadId])
    @@map("network_run")
}

// Network Step Execution
model NetworkRunStep {
    id    String     @id @default(cuid())
    runId String
    run   NetworkRun @relation(fields: [runId], references: [id], onDelete: Cascade)

    stepNumber Int
    stepType   String // "routing", "agent", "workflow", "tool"

    // What was executed
    primitiveType String?
    primitiveId   String?

    // Routing decision (for routing steps)
    routingDecision Json?

    // Execution details
    inputJson  Json?
    outputJson Json?
    errorJson  Json?

    status      RunStatus @default(QUEUED)
    startedAt   DateTime?
    completedAt DateTime?
    durationMs  Int?

    // Token usage for this step
    tokens  Int?
    costUsd Float?

    @@index([runId])
    @@index([stepNumber])
    @@map("network_run_step")
}

// Workflow Daily Metrics
model WorkflowMetricDaily {
    id               String   @id @default(cuid())
    workflowId       String
    workflow         Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
    date             DateTime @db.Date
    runs             Int      @default(0)
    successRate      Float?
    avgDurationMs    Float?
    suspensionRate   Float?
    avgStepsExecuted Float?

    @@unique([workflowId, date])
    @@map("workflow_metric_daily")
}

// Network Daily Metrics
model NetworkMetricDaily {
    id                  String   @id @default(cuid())
    networkId           String
    network             Network  @relation(fields: [networkId], references: [id], onDelete: Cascade)
    date                DateTime @db.Date
    runs                Int      @default(0)
    successRate         Float?
    avgDurationMs       Float?
    avgStepsExecuted    Float?
    avgRoutingDecisions Float?
    totalCostUsd        Float?

    // Primitive usage breakdown
    agentCallCount    Int @default(0)
    workflowCallCount Int @default(0)
    toolCallCount     Int @default(0)

    @@unique([networkId, date])
    @@map("network_metric_daily")
}

// Deployment Lifecycle
model Deployment {
    id String @id @default(cuid())

    // What is being deployed
    entityType String // "agent", "workflow", "network"
    entityId   String
    versionId  String

    // Environment
    environment String
    status      DeploymentStatus @default(DRAFT)

    // Approval
    approvedBy String?
    approvedAt DateTime?

    // Traffic
    trafficPercent Float?

    // Rollback
    previousDeploymentId String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([entityType, entityId, environment])
    @@index([entityType, entityId])
    @@map("deployment")
}

// BIM Version Status Enum
enum BimVersionStatus {
    QUEUED
    PROCESSING
    READY
    FAILED
}

// BIM Model
model BimModel {
    id           String  @id @default(cuid())
    name         String
    description  String? @db.Text
    sourceSystem String?
    metadata     Json?

    // Tenancy
    workspaceId String?
    workspace   Workspace? @relation(fields: [workspaceId], references: [id])
    ownerId     String?

    // Relations
    versions BimModelVersion[]
    takeoffs BimTakeoff[]
    diffs    BimDiffSummary[]
    clashes  BimClash[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([workspaceId])
    @@map("bim_model")
}

// BIM Model Version
model BimModelVersion {
    id String @id @default(cuid())

    modelId String
    model   BimModel @relation(fields: [modelId], references: [id], onDelete: Cascade)

    version      Int              @default(1)
    status       BimVersionStatus @default(QUEUED)
    sourceFormat String
    sourceUri    String?
    sourceKey    String?
    checksum     String?
    metadata     Json?

    // Relations
    elements  BimElement[]
    takeoffs  BimTakeoff[]
    clashes   BimClash[]
    diffsFrom BimDiffSummary[] @relation("BimDiffFrom")
    diffsTo   BimDiffSummary[] @relation("BimDiffTo")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([modelId, version])
    @@index([modelId])
    @@index([status])
    @@map("bim_model_version")
}

// BIM Element
model BimElement {
    id String @id @default(cuid())

    versionId String
    version   BimModelVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)

    elementGuid String
    name        String?
    category    String?
    type        String?
    family      String?
    system      String?
    level       String?
    phase       String?
    description String? @db.Text
    properties  Json?

    geometrySummary BimGeometrySummary?
    propertyEntries BimElementProperty[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([versionId, elementGuid])
    @@index([versionId])
    @@index([category])
    @@index([system])
    @@map("bim_element")
}

// BIM Element Geometry Summary
model BimGeometrySummary {
    id String @id @default(cuid())

    elementId String     @unique
    element   BimElement @relation(fields: [elementId], references: [id], onDelete: Cascade)

    bboxMin  Json?
    bboxMax  Json?
    centroid Json?
    length   Float?
    area     Float?
    volume   Float?
    units    String?
    metadata Json?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([elementId])
    @@map("bim_geometry_summary")
}

// BIM Element Properties (normalized)
model BimElementProperty {
    id String @id @default(cuid())

    elementId String
    element   BimElement @relation(fields: [elementId], references: [id], onDelete: Cascade)

    group        String?
    name         String
    valueString  String?
    valueNumber  Float?
    valueBoolean Boolean?
    unit         String?
    rawValue     Json?

    createdAt DateTime @default(now())

    @@index([elementId])
    @@index([name])
    @@map("bim_element_property")
}

// BIM Takeoff Results
model BimTakeoff {
    id String @id @default(cuid())

    modelId String?
    model   BimModel? @relation(fields: [modelId], references: [id], onDelete: SetNull)

    versionId String
    version   BimModelVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)

    scope     String?
    query     Json?
    result    Json
    createdBy String?

    createdAt DateTime @default(now())

    @@index([versionId])
    @@map("bim_takeoff")
}

// BIM Clash Results
model BimClash {
    id String @id @default(cuid())

    modelId String?
    model   BimModel? @relation(fields: [modelId], references: [id], onDelete: SetNull)

    versionId String
    version   BimModelVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)

    query     Json?
    result    Json
    createdBy String?

    createdAt DateTime @default(now())

    @@index([versionId])
    @@map("bim_clash")
}

// BIM Diff Summary
model BimDiffSummary {
    id String @id @default(cuid())

    modelId String?
    model   BimModel? @relation(fields: [modelId], references: [id], onDelete: SetNull)

    fromVersionId String
    fromVersion   BimModelVersion @relation("BimDiffFrom", fields: [fromVersionId], references: [id], onDelete: Cascade)

    toVersionId String
    toVersion   BimModelVersion @relation("BimDiffTo", fields: [toVersionId], references: [id], onDelete: Cascade)

    summary   Json
    createdBy String?

    createdAt DateTime @default(now())

    @@index([fromVersionId])
    @@index([toVersionId])
    @@map("bim_diff_summary")
}

// ==============================
// Document Primitive
// ==============================

model Document {
    id          String  @id @default(cuid())
    slug        String  @unique
    name        String
    description String? @db.Text
    content     String  @db.Text
    contentType String  @default("markdown")

    vectorIds  String[]
    chunkCount Int       @default(0)
    embeddedAt DateTime?

    category String?
    tags     String[]
    metadata Json?

    workspaceId String?
    workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)

    version  Int               @default(1)
    versions DocumentVersion[]
    skills   SkillDocument[]

    type      String   @default("USER") @map("doc_type")
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    createdBy String?

    @@index([workspaceId])
    @@index([category])
    @@map("document")
}

model DocumentVersion {
    id            String   @id @default(cuid())
    documentId    String
    document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
    version       Int
    content       String   @db.Text
    changeSummary String?
    createdAt     DateTime @default(now())
    createdBy     String?

    @@unique([documentId, version])
    @@map("document_version")
}

// ==============================
// Skill Primitive
// ==============================

model Skill {
    id           String  @id @default(cuid())
    slug         String // Per-workspace slug uniqueness
    name         String
    description  String? @db.Text
    instructions String  @db.Text
    examples     String? @db.Text

    category String?
    tags     String[]
    metadata Json?

    workspaceId String?
    workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)

    version  Int            @default(1)
    versions SkillVersion[]

    documents SkillDocument[]
    tools     SkillTool[]
    agents    AgentSkill[]

    type      String   @default("USER")
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    createdBy String?

    @@unique([workspaceId, slug]) // Per-workspace slug uniqueness
    @@index([slug])
    @@index([workspaceId])
    @@index([category])
    @@map("skill")
}

model SkillVersion {
    id            String   @id @default(cuid())
    skillId       String
    skill         Skill    @relation(fields: [skillId], references: [id], onDelete: Cascade)
    version       Int
    instructions  String   @db.Text
    configJson    Json?
    changeSummary String?
    createdAt     DateTime @default(now())
    createdBy     String?

    @@unique([skillId, version])
    @@map("skill_version")
}

model SkillDocument {
    id         String   @id @default(cuid())
    skillId    String
    skill      Skill    @relation(fields: [skillId], references: [id], onDelete: Cascade)
    documentId String
    document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
    role       String?

    @@unique([skillId, documentId])
    @@map("skill_document")
}

model SkillTool {
    id      String @id @default(cuid())
    skillId String
    skill   Skill  @relation(fields: [skillId], references: [id], onDelete: Cascade)
    toolId  String

    @@unique([skillId, toolId])
    @@map("skill_tool")
}

model AgentSkill {
    id      String  @id @default(cuid())
    agentId String
    agent   Agent   @relation(fields: [agentId], references: [id], onDelete: Cascade)
    skillId String
    skill   Skill   @relation(fields: [skillId], references: [id], onDelete: Cascade)
    pinned  Boolean @default(true) // true = always loaded at resolution (default), false = discoverable via meta-tools

    @@unique([agentId, skillId])
    @@map("agent_skill")
}

// Thread Skill State - Persists activated skills per conversation thread
// When an agent activates a skill via meta-tools during a conversation,
// the activation is stored here so subsequent turns in the same thread
// automatically load those skills without re-discovery.
model ThreadSkillState {
    id         String   @id @default(cuid())
    threadId   String   @unique
    agentId    String // Agent this state belongs to
    skillSlugs String[] // Activated skill slugs
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    @@index([threadId])
    @@index([agentId])
    @@map("thread_skill_state")
}

// ==============================
// Webhook Subscription Lifecycle
// ==============================

// WebhookSubscription - Tracks external push subscriptions (Graph, Dropbox, etc.)
model WebhookSubscription {
    id                      String                @id @default(cuid())
    integrationConnectionId String
    integrationConnection   IntegrationConnection @relation(fields: [integrationConnectionId], references: [id], onDelete: Cascade)
    providerKey             String // "microsoft-mail", "microsoft-calendar", "dropbox"
    externalSubscriptionId  String? // Graph subscription ID (null for Dropbox)
    resourcePath            String? // "/me/mailFolders('Inbox')/messages" etc
    clientState             String? // HMAC secret for Graph webhook verification
    notificationUrl         String? // Full webhook URL
    cursor                  String? // Dropbox delta cursor
    expiresAt               DateTime? // Graph subscription expiry (3-day max)
    lastRenewedAt           DateTime?
    errorCount              Int                   @default(0)
    errorMessage            String?               @db.Text
    isActive                Boolean               @default(true)
    metadata                Json?
    createdAt               DateTime              @default(now())
    updatedAt               DateTime              @updatedAt

    @@unique([integrationConnectionId, providerKey, resourcePath])
    @@index([providerKey, isActive])
    @@index([expiresAt])
    @@map("webhook_subscription")
}

// ==============================
// Calendar Event Primitive
// ==============================

// CalendarEvent - Normalized calendar events from Outlook/Google Calendar
model CalendarEvent {
    id                      String                 @id @default(cuid())
    organizationId          String
    integrationConnectionId String?
    integrationConnection   IntegrationConnection? @relation(fields: [integrationConnectionId], references: [id], onDelete: SetNull)
    externalEventId         String // Provider event ID (Graph event ID, Google event ID)
    calendarId              String? // Which calendar within the account
    subject                 String?
    bodyPreview             String?                @db.Text
    startAt                 DateTime?
    endAt                   DateTime?
    isAllDay                Boolean                @default(false)
    location                String?
    organizerEmail          String?
    attendeesJson           Json? // [{email, name, status}]
    recurrenceJson          Json? // Recurrence rule
    status                  String? // "confirmed", "tentative", "cancelled"
    sensitivity             String? // "normal", "personal", "private", "confidential"
    webLink                 String? // URL to open in browser
    metadata                Json?
    createdAt               DateTime               @default(now())
    updatedAt               DateTime               @updatedAt

    @@unique([integrationConnectionId, externalEventId])
    @@index([organizationId])
    @@index([startAt])
    @@map("calendar_event")
}

// SlackChannelPreference - Per-org/per-user channel routing for Slack agents
// Maps purpose keys (e.g., "support", "sales", "alerts") to Slack channel IDs.
// Linked to an IntegrationConnection (Slack installation) so each org has its own mappings.
model SlackChannelPreference {
    id                      String                @id @default(cuid())
    integrationConnectionId String
    integrationConnection   IntegrationConnection @relation(fields: [integrationConnectionId], references: [id], onDelete: Cascade)
    userId                  String? // Platform user ID (null = org-wide default)
    purposeKey              String // "support", "sales", "alerts", "general"
    channelId               String // Slack channel ID (C...)
    channelName             String? // Cached display name
    createdAt               DateTime              @default(now())
    updatedAt               DateTime              @updatedAt

    @@unique([integrationConnectionId, userId, purposeKey])
    @@index([integrationConnectionId])
    @@map("slack_channel_preference")
}

// SlackEventDedup - Prevents duplicate Slack event processing across multiple processes.
// Slack retries event delivery if it doesn't receive a timely 200. In a multi-process
// PM2 deployment, the in-memory dedup set is per-process. This table provides
// cross-process deduplication via a unique constraint on eventId.
model SlackEventDedup {
    eventId   String   @id
    expiresAt DateTime

    @@map("slack_event_dedup")
}

// ==============================
// Agent Instances  Channel-Agnostic Isolated Agent Contexts
// ==============================

// AgentInstance - A runtime instantiation of an agent template bound to a specific context
// (deal, customer, project). Owns its own memory namespace, RAG scope, and instruction overrides.
// The parent Agent provides the template (instructions, model, tools); the instance provides
// the per-deal/customer context layer. One agent template can serve N instances.
model AgentInstance {
    id             String       @id @default(cuid())
    agentId        String
    agent          Agent        @relation(fields: [agentId], references: [id], onDelete: Cascade)
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

    // Identity
    name String // "Owens Insulation Deal Manager"
    slug String // "owens-insulation"

    // Context binding (what this instance is "about")
    contextType      String? // "deal", "customer", "project"
    contextId        String? // External ID (HubSpot deal ID, Jira project key, etc.)
    contextData      Json? // Cached context for template injection
    contextRefreshAt DateTime? // When context was last refreshed from source

    // Instance-specific overrides (layered on top of agent template)
    instructionOverrides String? @db.Text // Appended to agent template instructions
    memoryNamespace      String  @unique // Cross-channel memory scope (default: "instance-{id}")
    ragCollectionId      String? // Scoped RAG document collection
    temperatureOverride  Float? // Override agent template temperature
    maxStepsOverride     Int? // Override agent template maxSteps

    metadata Json?
    isActive Boolean @default(true)
    version  Int     @default(1)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    createdBy String?

    // Relations
    channelBindings InstanceChannelBinding[]

    @@unique([organizationId, slug])
    @@index([agentId])
    @@index([contextType, contextId])
    @@index([organizationId])
    @@map("agent_instance")
}

// InstanceChannelBinding - Links an AgentInstance to a specific communication channel endpoint.
// Enables the same instance to be reached via Slack, email, WhatsApp, web embed, or voice.
// Memory is shared across all channel bindings for a given instance.
model InstanceChannelBinding {
    id         String        @id @default(cuid())
    instanceId String
    instance   AgentInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

    // Channel endpoint
    channelType       String // "slack", "email", "whatsapp", "web", "voice"
    channelIdentifier String // Slack channel ID, email address, phone number, embed token
    channelName       String? // Display name (#deal-owens, owens@agentc2.ai, etc.)
    channelMetadata   Json? // Channel-specific config (Slack teamId, etc.)

    // Per-channel behavior overrides
    replyMode      String? // "thread", "channel", "ephemeral" (null = use default)
    responseLength String? // "concise", "standard", "detailed"
    richFormatting Boolean? // Slack Block Kit / email HTML / etc.

    // Triggers (beyond default @mention behavior)
    triggerOnAllMessages Boolean  @default(false) // Respond to every message (no @mention needed)
    triggerKeywords      String[] @default([]) // Keywords that trigger response
    triggerOnFileUpload  Boolean  @default(false) // Trigger on file uploads

    // Access control
    allowedUserIds String[] @default([]) // Empty = everyone allowed
    blockedUserIds String[] @default([])

    isActive  Boolean  @default(true)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([channelType, channelIdentifier])
    @@index([instanceId])
    @@map("instance_channel_binding")
}

// ==============================
// Agent Scorecard & Calibration Models
// ==============================

// Scorecard Template - Reusable evaluation criteria templates for common agent types
model ScorecardTemplate {
    id          String  @id @default(cuid())
    slug        String  @unique
    name        String
    description String  @db.Text
    category    String // "crm", "email", "research", "support", "data", "general"
    criteria    Json // Array of ScorecardCriterion objects
    isSystem    Boolean @default(true) // System templates vs user-created

    // Relations
    scorecards AgentScorecard[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("scorecard_template")
}

// Agent Scorecard - Custom evaluation criteria per agent
model AgentScorecard {
    id       String  @id @default(cuid())
    agentId  String  @unique
    agent    Agent   @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId String?

    // Core content
    criteria Json // Array of ScorecardCriterion objects
    version  Int  @default(1)

    // Template tracking
    templateId String?
    template   ScorecardTemplate? @relation(fields: [templateId], references: [id])

    // Evaluation config
    samplingRate  Float   @default(1.0) // 0.0-1.0, % of runs that get Tier 2 AI audit
    auditorModel  String  @default("gpt-4o-mini") // Which model for auditing
    evaluateTurns Boolean @default(false) // Whether to evaluate individual turns

    // Audit
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    createdBy String?

    @@index([agentId])
    @@index([tenantId])
    @@map("agent_scorecard")
}

// Calibration Check - Compares AI auditor scores vs human feedback
model CalibrationCheck {
    id           String          @id @default(cuid())
    evaluationId String
    evaluation   AgentEvaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)
    agentId      String
    agent        Agent           @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId     String?

    // Comparison data
    auditorGrade Float // The auditor's overall grade
    humanRating  Float // Normalized human rating (thumbs mapped to 0/1, rating to 0-1)
    disagreement Float // |auditorGrade - humanRating|
    feedbackId   String // Reference to AgentFeedback record
    humanComment String? @db.Text

    // Classification
    aligned   Boolean // disagreement < threshold (e.g., 0.3)
    direction String? // "auditor_higher" | "auditor_lower" | "aligned"

    createdAt DateTime @default(now())

    @@index([agentId, createdAt])
    @@index([tenantId])
    @@map("calibration_check")
}

// Network Run Evaluation - Routing quality assessment for network runs
model NetworkRunEvaluation {
    id           String     @id @default(cuid())
    networkRunId String     @unique
    networkRun   NetworkRun @relation(fields: [networkRunId], references: [id], onDelete: Cascade)
    networkId    String
    routingScore Float?
    agentScores  Json? // {agentSlug: avgGrade} from nested agent evaluations
    narrative    String?    @db.Text
    createdAt    DateTime   @default(now())

    @@map("network_run_evaluation")
}

// Workflow Test Case
model WorkflowTestCase {
    id             String   @id @default(cuid())
    workflowId     String
    workflow       Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
    name           String
    inputJson      Json
    expectedOutput Json?
    tags           String[] @default([])
    createdBy      String?
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    @@index([workflowId])
    @@map("workflow_test_case")
}

// Network Test Case
model NetworkTestCase {
    id             String   @id @default(cuid())
    networkId      String
    network        Network  @relation(fields: [networkId], references: [id], onDelete: Cascade)
    name           String
    inputText      String   @db.Text
    expectedOutput String?  @db.Text
    tags           String[] @default([])
    createdBy      String?
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    @@index([networkId])
    @@map("network_test_case")
}

// Workflow Run Feedback
model WorkflowRunFeedback {
    id            String      @id @default(cuid())
    workflowRunId String
    workflowRun   WorkflowRun @relation(fields: [workflowRunId], references: [id], onDelete: Cascade)
    workflowId    String
    thumbs        Boolean? // true = up, false = down
    rating        Int? // 1-5 scale
    comment       String?     @db.Text
    source        String? // "ui" | "api"
    createdAt     DateTime    @default(now())

    @@index([workflowRunId])
    @@index([workflowId])
    @@map("workflow_run_feedback")
}

// Network Run Feedback
model NetworkRunFeedback {
    id           String     @id @default(cuid())
    networkRunId String
    networkRun   NetworkRun @relation(fields: [networkRunId], references: [id], onDelete: Cascade)
    networkId    String
    thumbs       Boolean? // true = up, false = down
    rating       Int? // 1-5 scale
    comment      String?    @db.Text
    source       String? // "ui" | "api"
    createdAt    DateTime   @default(now())

    @@index([networkRunId])
    @@index([networkId])
    @@map("network_run_feedback")
}

// ==============================
// Admin Portal Models
// ==============================

// AdminUser - Internal staff users for the admin portal (separate auth domain)
model AdminUser {
    id          String    @id @default(cuid())
    email       String    @unique
    name        String
    password    String // bcrypt hashed
    role        String    @default("viewer") // "super_admin","platform_admin","billing_admin","support_agent","viewer"
    mfaEnabled  Boolean   @default(false)
    mfaSecret   String?
    isActive    Boolean   @default(true)
    lastLoginAt DateTime?
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt

    sessions        AdminSession[]
    auditLogs       AdminAuditLog[]
    impersonations  ImpersonationSession[]
    assignedTickets SupportTicket[]

    @@map("admin_user")
}

// AdminSession - Session tracking for admin users
model AdminSession {
    id          String    @id @default(cuid())
    adminUserId String
    adminUser   AdminUser @relation(fields: [adminUserId], references: [id], onDelete: Cascade)
    token       String    @unique
    ipAddress   String?
    userAgent   String?
    expiresAt   DateTime
    createdAt   DateTime  @default(now())

    @@index([adminUserId])
    @@index([token])
    @@map("admin_session")
}

// AdminAuditLog - Audit trail for all admin portal actions
model AdminAuditLog {
    id          String    @id @default(cuid())
    adminUserId String
    adminUser   AdminUser @relation(fields: [adminUserId], references: [id])
    action      String // "TENANT_SUSPEND","USER_IMPERSONATE","FLAG_TOGGLE", etc.
    entityType  String
    entityId    String
    beforeJson  Json?
    afterJson   Json?
    ipAddress   String
    userAgent   String?
    metadata    Json?
    createdAt   DateTime  @default(now())

    @@index([adminUserId, createdAt])
    @@index([entityType, entityId])
    @@index([action, createdAt])
    @@map("admin_audit_log")
}

// AdminSetting - Global admin portal system settings
model AdminSetting {
    id        String   @id @default(cuid())
    key       String   @unique
    value     Json
    updatedBy String?
    updatedAt DateTime @updatedAt
    createdAt DateTime @default(now())

    @@map("admin_setting")
}

// FeatureFlag - Global feature flags managed via admin portal
model FeatureFlag {
    id           String   @id @default(cuid())
    key          String   @unique
    name         String
    description  String?
    flagType     String   @default("boolean") // "boolean","percentage","string"
    defaultValue String   @default("false")
    isActive     Boolean  @default(true)
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    overrides FeatureFlagOverride[]

    @@map("feature_flag")
}

// FeatureFlagOverride - Per-tenant overrides for feature flags
model FeatureFlagOverride {
    id             String       @id @default(cuid())
    flagId         String
    flag           FeatureFlag  @relation(fields: [flagId], references: [id], onDelete: Cascade)
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    value          String
    reason         String?
    setBy          String?
    expiresAt      DateTime?
    createdAt      DateTime     @default(now())

    @@unique([flagId, organizationId])
    @@map("feature_flag_override")
}

// TenantLifecycleEvent - Tracks status transitions for organizations
model TenantLifecycleEvent {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    fromStatus     String
    toStatus       String
    reason         String?      @db.Text
    performedBy    String? // AdminUser ID
    metadata       Json?
    createdAt      DateTime     @default(now())

    @@index([organizationId, createdAt])
    @@map("tenant_lifecycle_event")
}

// Agent Recommendation - AAR-generated recommendations with lifecycle management
model AgentRecommendation {
    id           String           @id @default(cuid())
    agentId      String
    agent        Agent            @relation(fields: [agentId], references: [id], onDelete: Cascade)
    evaluationId String?
    evaluation   AgentEvaluation? @relation(fields: [evaluationId], references: [id])
    tenantId     String?
    type         String // "sustain" | "improve" | "skill_development" | "document_creation"
    category     String // "classification" | "enrichment" | "tone" | "routing" | "safety"
    title        String
    description  String           @db.Text
    evidence     Json? // Run/trace evidence supporting this recommendation
    priority     String? // "high" | "medium" | "low"
    status       String           @default("active") // "active" | "graduated" | "expired" | "rejected"
    graduatedTo  String? // "instruction_change" | "skill_update" | "document" | "learning_signal"
    graduatedRef String? // ID of the entity it graduated into
    frequency    Int              @default(1) // Incremented on dedup match
    expiresAt    DateTime?
    createdAt    DateTime         @default(now())
    updatedAt    DateTime         @updatedAt

    @@index([agentId, status])
    @@index([agentId, type])
    @@index([tenantId])
    @@map("agent_recommendation")
}

// ImpersonationSession - Tracks when admin users impersonate customer users
model ImpersonationSession {
    id           String       @id @default(cuid())
    adminUserId  String
    adminUser    AdminUser    @relation(fields: [adminUserId], references: [id])
    targetUserId String
    targetOrgId  String
    organization Organization @relation(fields: [targetOrgId], references: [id])
    reason       String       @db.Text
    ipAddress    String
    startedAt    DateTime     @default(now())
    endedAt      DateTime?
    expiresAt    DateTime // auto-expire after 30 min

    @@index([adminUserId, startedAt])
    @@index([targetUserId])
    @@map("impersonation_session")
}

// ==============================
// Campaign / Mission / Task Models
// ==============================

enum CampaignStatus {
    PLANNING
    ANALYZING
    READY
    EXECUTING
    REVIEWING
    COMPLETE
    FAILED
    PAUSED
}

enum MissionStatus {
    PENDING
    ANALYZING
    READY
    EXECUTING
    REVIEWING
    REWORK
    AWAITING_APPROVAL
    COMPLETE
    FAILED
    SKIPPED
}

enum MissionTaskStatus {
    PENDING
    RUNNING
    COMPLETE
    FAILED
    SKIPPED
}

enum MissionTaskType {
    ASSIGNED
    IMPLIED
    ESSENTIAL
}

// Campaign - Top-level objective container (Mission Command)
model Campaign {
    id        String         @id @default(cuid())
    slug      String         @unique
    name      String
    status    CampaignStatus @default(PLANNING)
    tenantId  String?
    createdBy String? // userId
    ownerId   String? // agentId of the "commander" agent, if any

    // Mission Command fields
    intent      String   @db.Text // Commander's intent: the WHY
    endState    String   @db.Text // Desired end state
    description String?  @db.Text // Optional additional context
    constraints String[] // Must-do requirements
    restraints  String[] // Must-not-do requirements

    // Planning outputs
    analysisOutput Json? // Task decomposition: assigned/implied/essential tasks
    executionPlan  Json? // Phases, resource allocation, agent assignments, dependencies

    // Review
    aarJson Json? // Campaign-level AAR: plan vs actual, aggregated scores, lessons

    // Dynamic Resources (agents/skills created by campaign-architect)
    generatedResources Json? // { agents: [{slug, name, id}], skills: [{slug, name, id}], documents: [...] }

    // Configuration
    requireApproval Boolean @default(false) // Pause for human review before execution
    maxCostUsd      Float? // Budget ceiling
    timeoutMinutes  Int? // Max execution time

    // Template support
    templateId      String?
    template        CampaignTemplate? @relation(fields: [templateId], references: [id])
    runNumber       Int? // Sequential run number for recurring campaigns
    parameterValues Json? // Actual parameter values used for this run

    // Sub-campaign hierarchy
    parentCampaignId String?
    parentCampaign   Campaign?  @relation("CampaignHierarchy", fields: [parentCampaignId], references: [id], onDelete: SetNull)
    childCampaigns   Campaign[] @relation("CampaignHierarchy")
    depth            Int        @default(0) // 0 = root, max = MAX_CAMPAIGN_DEPTH

    // Metrics (updated during execution)
    totalCostUsd Float     @default(0)
    totalTokens  Int       @default(0)
    progress     Float     @default(0) // 0-100
    startedAt    DateTime?
    completedAt  DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    missions Mission[]
    logs     CampaignLog[]

    @@index([tenantId])
    @@index([status])
    @@index([createdBy])
    @@index([templateId])
    @@index([parentCampaignId])
    @@map("campaign")
}

// CampaignTemplate - Reusable campaign definitions with optional scheduling
model CampaignTemplate {
    id               String   @id @default(cuid())
    slug             String   @unique
    name             String
    description      String?  @db.Text
    category         String? // "sales", "operations", "safety", etc.
    intentTemplate   String   @db.Text // Supports {{paramName}} interpolation
    endStateTemplate String   @db.Text
    constraints      String[]
    restraints       String[]
    parameters       Json? // { "customerName": { type: "string", required: true } }
    requireApproval  Boolean  @default(false)
    maxCostUsd       Float?
    timeoutMinutes   Int?
    isSystem         Boolean  @default(false)
    isActive         Boolean  @default(true)
    createdBy        String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    campaigns Campaign[]
    schedules CampaignSchedule[]
    triggers  CampaignTrigger[]

    @@map("campaign_template")
}

// CampaignSchedule - Cron-based recurring campaign execution
model CampaignSchedule {
    id         String           @id @default(cuid())
    templateId String
    template   CampaignTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
    name       String
    cronExpr   String
    timezone   String           @default("UTC")
    inputJson  Json? // Parameter values for template interpolation
    isActive   Boolean          @default(true)
    lastRunAt  DateTime?
    nextRunAt  DateTime?
    runCount   Int              @default(0)
    createdBy  String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([isActive, nextRunAt])
    @@map("campaign_schedule")
}

// CampaignTrigger - Event/webhook-driven campaign instantiation
model CampaignTrigger {
    id              String           @id @default(cuid())
    templateId      String
    template        CampaignTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
    name            String
    triggerType     String // "webhook", "event"
    eventName       String?
    webhookPath     String?          @unique
    webhookSecret   String?
    inputMapping    Json? // Maps payload fields to template parameters
    filterJson      Json? // Conditions to match before triggering
    isActive        Boolean          @default(true)
    lastTriggeredAt DateTime?
    triggerCount    Int              @default(0)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([eventName])
    @@index([triggerType, isActive])
    @@map("campaign_trigger")
}

// Mission - A group of related tasks within a campaign
model Mission {
    id         String        @id @default(cuid())
    campaignId String
    campaign   Campaign      @relation(fields: [campaignId], references: [id], onDelete: Cascade)
    name       String
    status     MissionStatus @default(PENDING)
    priority   Int           @default(0) // Higher = more important
    sequence   Int           @default(0) // Execution order (0 = parallel OK)

    // Mission statement: "verb + in order to purpose"
    missionStatement String @db.Text

    // Planning
    assignedAgentId String? // Which agent or network handles this mission
    executionPlan   Json? // Mission-level plan
    actionsOn       Json? // Contingency handlers: { apiFailure, budgetExhausted, default }

    // Review
    aarJson Json? // Mission-level AAR aggregating task results

    // Review-Rework Loop
    maxIterations    Int     @default(1) // Max times this mission can execute (1 = no rework)
    currentIteration Int     @default(1) // Current iteration number
    reworkReason     String? @db.Text // Feedback from reviewer triggering rework

    // Approval Gates
    requiresApproval Boolean   @default(false) // Pause after this mission for human approval
    approvedBy       String?
    approvedAt       DateTime?
    approvalNotes    String?   @db.Text

    // Metrics
    totalCostUsd Float     @default(0)
    totalTokens  Int       @default(0)
    startedAt    DateTime?
    completedAt  DateTime?

    // Nested missions (optional)
    parentMissionId String?
    parentMission   Mission?  @relation("MissionHierarchy", fields: [parentMissionId], references: [id], onDelete: SetNull)
    childMissions   Mission[] @relation("MissionHierarchy")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    tasks MissionTask[]

    @@index([campaignId, sequence])
    @@index([status])
    @@index([parentMissionId])
    @@map("mission")
}

// MissionTask - Individual work item assigned to an agent
model MissionTask {
    id        String            @id @default(cuid())
    missionId String
    mission   Mission           @relation(fields: [missionId], references: [id], onDelete: Cascade)
    name      String
    status    MissionTaskStatus @default(PENDING)
    taskType  MissionTaskType   @default(ASSIGNED)
    taskVerb  String // The specific action verb

    // Assignment
    assignedAgentId String? // Which agent handles this task
    sequence        Int     @default(0) // Execution order within mission

    // Execution link -- bridges to existing evaluation pipeline
    agentRunId String?   @unique
    agentRun   AgentRun? @relation(fields: [agentRunId], references: [id], onDelete: SetNull)

    // Task details
    coordinatingInstructions Json? // Dependencies, timings, context to pass to agent
    result                   Json? // Execution result summary
    error                    String? @db.Text

    // Metrics
    costUsd     Float?
    tokens      Int?
    startedAt   DateTime?
    completedAt DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([missionId, sequence])
    @@index([status])
    @@index([assignedAgentId])
    @@map("mission_task")
}

// CampaignLog - Audit trail for campaign events
model CampaignLog {
    id         String   @id @default(cuid())
    campaignId String
    campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
    event      String // "created", "analyzing", "planned", "executing", "task_complete", "mission_aar", "campaign_aar", "failed", "escalated"
    message    String   @db.Text
    metadata   Json? // Additional event data
    createdAt  DateTime @default(now())

    @@index([campaignId, createdAt])
    @@map("campaign_log")
}

// ============================================================================
// Activity Feed & Backlog System
// ============================================================================

// ActivityEvent - Denormalized event store for the unified Activity Feed.
// Every significant platform event gets a row. Single-table query for fast reads.
model ActivityEvent {
    id        String            @id @default(cuid())
    type      ActivityEventType
    timestamp DateTime          @default(now())

    // Actor
    agentId   String?
    agentSlug String?
    agentName String?
    userId    String?

    // Content
    summary String  @db.Text // Human-readable event description
    detail  String? @db.Text // Extended detail for drill-down
    status  String? // "success", "failure", "info", "warning"

    // Context links
    source       String? // "slack", "schedule", "webhook", "api", "heartbeat", "campaign"
    runId        String? // Link to AgentRun
    taskId       String? // Link to BacklogTask
    networkRunId String? // Link to NetworkRun
    campaignId   String? // Link to Campaign

    // Metrics (denormalized for feed display without joins)
    costUsd    Float?
    durationMs Int?
    tokenCount Int?

    // Metadata
    metadata Json?
    tags     String[]

    // Tenancy
    tenantId    String?
    workspaceId String?

    @@index([timestamp])
    @@index([agentId, timestamp])
    @@index([type, timestamp])
    @@index([source, timestamp])
    @@index([tenantId, timestamp])
    @@index([workspaceId, timestamp])
    @@map("activity_event")
}

enum ActivityEventType {
    // Agent execution
    RUN_COMPLETED
    RUN_FAILED
    RUN_STARTED

    // Heartbeat
    HEARTBEAT_RAN
    HEARTBEAT_ALERT

    // Backlog
    TASK_CREATED
    TASK_COMPLETED
    TASK_FAILED
    TASK_DEFERRED

    // Network delegation
    NETWORK_ROUTED
    NETWORK_COMPLETED

    // Campaign
    CAMPAIGN_STARTED
    CAMPAIGN_COMPLETED
    CAMPAIGN_FAILED
    MISSION_COMPLETED

    // Triggers
    TRIGGER_FIRED
    SCHEDULE_EXECUTED

    // Communication
    SLACK_MESSAGE_HANDLED
    EMAIL_PROCESSED

    // Platform
    AGENT_CREATED
    AGENT_UPDATED
    SKILL_CREATED
    INTEGRATION_EVENT
    GUARDRAIL_TRIGGERED
    ALERT_RAISED

    // System
    SYSTEM_EVENT
}

// Backlog - An agent's persistent work queue. One per agent.
model Backlog {
    id          String  @id @default(cuid())
    agentId     String  @unique
    agent       Agent   @relation(fields: [agentId], references: [id], onDelete: Cascade)
    name        String  @default("Backlog")
    description String? @db.Text
    tenantId    String?
    workspaceId String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    tasks BacklogTask[]

    @@index([agentId])
    @@index([tenantId])
    @@map("backlog")
}

// BacklogTask - A work item on an agent's backlog.
model BacklogTask {
    id          String            @id @default(cuid())
    backlogId   String
    backlog     Backlog           @relation(fields: [backlogId], references: [id], onDelete: Cascade)
    title       String
    description String?           @db.Text
    status      BacklogTaskStatus @default(PENDING)
    priority    Int               @default(5) // 0=low, 10=critical

    // Scheduling
    dueDate DateTime?

    // Source tracking
    source      String? // "human", "agent", "heartbeat", "campaign", "trigger", "slack"
    createdById String? // userId or agentSlug that created this task

    // Execution
    agentRunId      String? // Link to the AgentRun that processed this task
    lastAttemptAt   DateTime?
    lastAttemptNote String?   @db.Text

    // Context and result
    contextJson Json?
    tags        String[]
    result      String?   @db.Text
    completedAt DateTime?

    // Coding Pipeline
    pipelineRunId String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([backlogId, status, priority])
    @@index([backlogId, dueDate])
    @@index([status])
    @@map("backlog_task")
}

enum BacklogTaskStatus {
    PENDING
    IN_PROGRESS
    COMPLETED
    FAILED
    DEFERRED
}

// Output Action - Configurable output destinations for agent run results
// Handles plumbing (webhooks, agent chaining). Agents own their own communication via MCP tools.
model OutputAction {
    id         String           @id @default(cuid())
    agentId    String
    agent      Agent            @relation(fields: [agentId], references: [id], onDelete: Cascade)
    tenantId   String?
    name       String
    type       OutputActionType
    configJson Json
    isActive   Boolean          @default(true)
    createdAt  DateTime         @default(now())
    updatedAt  DateTime         @updatedAt
    createdBy  String?

    @@index([agentId, isActive])
    @@index([tenantId])
    @@map("output_action")
}

enum OutputActionType {
    WEBHOOK
    CHAIN_AGENT
}

// Platform Invite - Access codes that let users past the waitlist to create their own org
// Separate from OrganizationInvite which joins users into an existing org
model PlatformInvite {
    id        String    @id @default(cuid())
    code      String    @unique
    label     String? // human-readable label, e.g. "YC Demo Day batch"
    expiresAt DateTime?
    maxUses   Int?
    usedCount Int       @default(0)
    isActive  Boolean   @default(true)
    createdBy String?
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt

    @@map("platform_invite")
}

// Waitlist - Collects emails from users who want early access
model Waitlist {
    id        String   @id @default(cuid())
    email     String   @unique
    name      String?
    source    String? // "landing", "signup-redirect", etc.
    status    String   @default("pending") // "pending", "invited", "registered"
    inviteId  String? // link to OrganizationInvite if one was created for them
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("waitlist")
}

// ==============================
// Support Ticket System
// ==============================

enum TicketType {
    BUG
    FEATURE_REQUEST
    IMPROVEMENT
    QUESTION
}

enum TicketStatus {
    NEW
    TRIAGED
    IN_PROGRESS
    WAITING_ON_CUSTOMER
    RESOLVED
    CLOSED
}

enum TicketPriority {
    CRITICAL
    HIGH
    MEDIUM
    LOW
}

// SupportTicket - Bug reports, feature requests, and questions from org users
model SupportTicket {
    id           String         @id @default(cuid())
    ticketNumber Int            @unique @default(autoincrement())
    type         TicketType
    status       TicketStatus   @default(NEW)
    priority     TicketPriority @default(MEDIUM)
    title        String
    description  String         @db.Text

    // Submitter
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id])
    submittedById  String
    submittedBy    User         @relation(fields: [submittedById], references: [id])

    // Assignment
    assignedToId String?
    assignedTo   AdminUser? @relation(fields: [assignedToId], references: [id])

    // Metadata
    tags     String[] @default([])
    metadata Json?

    // Lifecycle timestamps
    triagedAt  DateTime?
    resolvedAt DateTime?
    closedAt   DateTime?

    // Coding Pipeline
    pipelineRunId String?

    // Comments
    comments SupportTicketComment[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([organizationId])
    @@index([submittedById])
    @@index([status])
    @@index([type])
    @@index([priority])
    @@index([createdAt])
    @@map("support_ticket")
}

// SupportTicketComment - Threaded comments on tickets (from users or admins)
model SupportTicketComment {
    id       String        @id @default(cuid())
    ticketId String
    ticket   SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

    // Author (either "user" or "admin")
    authorType String
    authorId   String
    authorName String

    content    String  @db.Text
    isInternal Boolean @default(false) // Admin-only notes not visible to users

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([ticketId])
    @@index([createdAt])
    @@map("support_ticket_comment")
}

// ==============================
// Platform Security
// ==============================

// OrganizationKeyPair - Ed25519 key pairs for org identity and message signing
model OrganizationKeyPair {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

    publicKey           String // Ed25519 public key (base64-encoded DER)
    encryptedPrivateKey Json // Private key encrypted with platform KEK (AES-256-GCM payload)
    keyVersion          Int    @default(1)
    algorithm           String @default("Ed25519")

    status    String    @default("active") // "active", "rotated", "revoked"
    rotatedAt DateTime?
    revokedAt DateTime?
    expiresAt DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([organizationId, keyVersion])
    @@index([organizationId, status])
    @@map("organization_key_pair")
}

// FederationAuditLog - Federation-specific audit trail for cross-org interactions
model FederationAuditLog {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id])

    // Who
    actorType  String // "user", "agent", "system", "federation_agent"
    actorId    String // userId, agentSlug, "system", or "orgSlug:agentSlug"
    actorOrgId String? // For cross-org actions: the originating org

    // What
    action   String // "federation.request", "federation.approve", "federation.invoke"
    resource String // "federation_agreement:clx123", "agent:deal-copilot"
    outcome  String // "success", "denied", "error"

    // Context
    metadata  Json?
    ipAddress String?
    userAgent String?

    createdAt DateTime @default(now())

    @@index([organizationId, createdAt])
    @@index([organizationId, action])
    @@index([actorId, createdAt])
    @@map("federation_audit_log")
}

// ==============================
// Federation
// ==============================

// FederationAgreement - Trust relationship between two organizations
model FederationAgreement {
    id String @id @default(cuid())

    // Parties
    initiatorOrgId String
    initiatorOrg   Organization @relation("FederationInitiator", fields: [initiatorOrgId], references: [id])
    responderOrgId String
    responderOrg   Organization @relation("FederationResponder", fields: [responderOrgId], references: [id])

    // Lifecycle
    status            String    @default("pending") // "pending", "active", "suspended", "revoked"
    requestedAt       DateTime  @default(now())
    requestedByUserId String
    approvedAt        DateTime?
    approvedByUserId  String?
    suspendedAt       DateTime?
    suspendedReason   String?   @db.Text
    revokedAt         DateTime?
    revokedByUserId   String?
    revokedReason     String?   @db.Text

    // Agent Scoping
    exposures FederationExposure[]

    // Security (channel key encrypted with platform KEK)
    channelKeyEncrypted Json // AES-256-GCM encrypted payload containing the channel symmetric key
    channelKeyVersion   Int  @default(1)
    initiatorKeyVersion Int // Ed25519 key version of initiator org at agreement time
    responderKeyVersion Int? // Set when responder approves

    // Governance
    maxRequestsPerHour   Int     @default(500)
    maxRequestsPerDay    Int     @default(5000)
    dataClassification   String  @default("internal") // "public", "internal", "confidential", "restricted"
    allowFileTransfer    Boolean @default(false)
    allowStructuredData  Boolean @default(true)
    requireHumanApproval Boolean @default(false)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    messages FederationMessage[]

    @@unique([initiatorOrgId, responderOrgId])
    @@index([initiatorOrgId, status])
    @@index([responderOrgId, status])
    @@map("federation_agreement")
}

// FederationExposure - Which agents an org shares within a federation agreement
model FederationExposure {
    id          String              @id @default(cuid())
    agreementId String
    agreement   FederationAgreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)

    // Which org is exposing
    ownerOrgId String
    ownerOrg   Organization @relation(fields: [ownerOrgId], references: [id])

    // Which agent
    agentId String
    agent   Agent  @relation(fields: [agentId], references: [id])

    // What skills/tools are exposed (empty array = all non-internal tools)
    exposedSkills String[] @default([])

    // Plain-english description of what the partner can do
    accessSummary String? @db.Text

    // Per-exposure overrides
    maxRequestsPerHour Int?
    enabled            Boolean @default(true)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([agreementId, ownerOrgId, agentId])
    @@index([agreementId])
    @@index([ownerOrgId])
    @@map("federation_exposure")
}

// FederationMessage - Encrypted, signed record of every cross-org agent interaction
model FederationMessage {
    id          String              @id @default(cuid())
    agreementId String
    agreement   FederationAgreement @relation(fields: [agreementId], references: [id])

    // Routing
    conversationId  String
    direction       String // "initiator_to_responder" or "responder_to_initiator"
    sourceOrgId     String
    sourceAgentSlug String
    targetOrgId     String
    targetAgentSlug String

    // Content (encrypted at rest with channel key)
    encryptedContent String @db.Text // AES-256-GCM encrypted payload (JSON string)
    contentType      String @default("text") // "text", "structured", "tool_result"
    iv               String // Initialization vector for decryption

    // Integrity
    senderSignature  String // Ed25519 signature of plaintext content by sender org
    senderKeyVersion Int // Which key version was used to sign

    // Metadata (not encrypted -- needed for routing, billing, monitoring)
    latencyMs     Int?
    inputTokens   Int?
    outputTokens  Int?
    costUsd       Float?
    policyResult  String  @default("approved") // "approved", "filtered", "blocked"
    policyDetails Json?
    runId         String? // Agent run ID created by this message's execution

    createdAt DateTime @default(now())

    @@index([agreementId, conversationId, createdAt])
    @@index([sourceOrgId, createdAt])
    @@map("federation_message")
}

//  Infrastructure Provisioning 

model ProvisionedResource {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    agentId        String?
    runId          String?
    provider       String // "digitalocean", "supabase", "custom"
    resourceType   String // "droplet", "database", "domain", "ssh-key", "app"
    externalId     String // Provider's resource ID
    name           String
    metadata       Json? // IP address, connection strings, specs, region
    status         String       @default("active") // "active", "destroyed", "error"
    monthlyCostUsd Float?
    createdAt      DateTime     @default(now())
    updatedAt      DateTime     @updatedAt
    destroyedAt    DateTime?

    @@index([organizationId, status])
    @@index([provider, resourceType])
    @@index([agentId])
    @@map("provisioned_resource")
}

//  Coding Pipeline 

model CodingPipelineRun {
    id             String  @id @default(cuid())
    workflowRunId  String? // Links to WorkflowRun
    organizationId String?

    // Source ticket/task/issue
    sourceType String // "support_ticket", "backlog_task", "github_issue", "manual"
    sourceId   String

    // Repository context
    repository   String
    baseBranch   String  @default("main")
    targetBranch String?

    // Cursor Cloud Agent
    cursorAgentId String?

    // Pull Request
    prNumber Int?
    prUrl    String?

    // Governance
    riskLevel String? // "trivial", "low", "medium", "high", "critical"
    variant   String  @default("standard") // "standard" or "internal"

    // Cost tracking
    totalCostUsd Float?

    // Trust score for autonomous merge decisions
    trustScore Float?

    // Lifecycle
    status    String   @default("running") // running, awaiting_plan_approval, coding, verifying, awaiting_pr_review, merged, deployed, failed
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([organizationId, status])
    @@index([sourceType, sourceId])
    @@index([status])
    @@index([createdAt])
    @@map("coding_pipeline_run")
}

// Dark Factory: per-org autonomy configuration
model PipelinePolicy {
    id                   String       @id @default(cuid())
    organizationId       String       @unique
    organization         Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    enabled              Boolean      @default(false)
    autoApprovePlanBelow String       @default("medium") // trivial < low < medium < high < critical
    autoApprovePrBelow   String       @default("low")
    allowedRepos         String[]     @default([])
    createdAt            DateTime     @default(now())
    updatedAt            DateTime     @updatedAt

    @@map("pipeline_policy")
}

// Dark Factory: per-org, per-repo build configuration
model RepositoryConfig {
    id              String       @id @default(cuid())
    organizationId  String
    organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    repositoryUrl   String
    name            String?
    baseBranch      String       @default("main")
    installCommand  String       @default("bun install")
    buildCommand    String       @default("bun run type-check && bun run lint && bun run build")
    testCommand     String?
    codingStandards String?      @db.Text
    codingAgentSlug String?
    metadata        Json?
    createdAt       DateTime     @default(now())
    updatedAt       DateTime     @updatedAt

    scenarios PipelineScenario[]

    @@unique([organizationId, repositoryUrl])
    @@index([organizationId])
    @@map("repository_config")
}

// Dark Factory: behavioral scenario definitions per repo
model PipelineScenario {
    id                 String                @id @default(cuid())
    repositoryConfig   RepositoryConfig      @relation(fields: [repositoryConfigId], references: [id], onDelete: Cascade)
    repositoryConfigId String
    name               String
    description        String?               @db.Text
    prompt             String                @db.Text
    expectedOutcome    String?               @db.Text
    isHoldout          Boolean               @default(false)
    isActive           Boolean               @default(true)
    createdAt          DateTime              @default(now())
    updatedAt          DateTime              @updatedAt
    runs               PipelineScenarioRun[]

    @@index([repositoryConfigId, isActive])
    @@map("pipeline_scenario")
}

// Dark Factory: scenario execution results
model PipelineScenarioRun {
    id            String           @id @default(cuid())
    scenario      PipelineScenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
    scenarioId    String
    pipelineRunId String?
    passed        Boolean
    output        String?          @db.Text
    durationMs    Int?
    createdAt     DateTime         @default(now())

    @@index([scenarioId])
    @@index([pipelineRunId])
    @@map("pipeline_scenario_run")
}

// Dark Factory: daily pipeline autonomy metrics
model PipelineDailyStats {
    id             String   @id @default(cuid())
    organizationId String
    date           DateTime @db.Date
    totalRuns      Int      @default(0)
    autoApproved   Int      @default(0)
    humanApproved  Int      @default(0)
    failed         Int      @default(0)
    deployed       Int      @default(0)
    avgTrustScore  Float?
    avgDurationMs  Int?
    createdAt      DateTime @default(now())

    @@unique([organizationId, date])
    @@index([organizationId])
    @@map("pipeline_daily_stats")
}

// ==============================
// Budget Management & Pricing Models
// ==============================

// Pricing Plan - Admin-managed plan definitions
model PricingPlan {
    id          String  @id @default(cuid())
    slug        String  @unique
    name        String
    description String? @db.Text
    isActive    Boolean @default(true)
    sortOrder   Int     @default(0)

    monthlyPriceUsd Float
    annualPriceUsd  Float?
    perSeatPricing  Boolean @default(false)

    includedCreditsUsd Float   @default(0)
    markupMultiplier   Float   @default(2.0)
    overageEnabled     Boolean @default(false)
    overageMarkup      Float?

    maxAgents       Int?
    maxSeats        Int?
    maxRunsPerMonth Int?
    maxWorkspaces   Int?
    maxStorageBytes BigInt?
    maxIntegrations Int?

    features Json?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    subscriptions OrgSubscription[]

    @@map("pricing_plan")
}

// Org Subscription - Links an organization to a pricing plan
model OrgSubscription {
    id             String       @id @default(cuid())
    organizationId String       @unique
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    planId         String
    plan           PricingPlan  @relation(fields: [planId], references: [id])

    status             String    @default("active")
    billingCycle       String    @default("monthly")
    currentPeriodStart DateTime  @default(now())
    currentPeriodEnd   DateTime
    trialEndsAt        DateTime?
    canceledAt         DateTime?

    stripeSubscriptionId String? @unique
    stripeCustomerId     String?

    includedCreditsUsd Float @default(0)
    usedCreditsUsd     Float @default(0)

    overageSpendLimitUsd Float?
    overageAccruedUsd    Float  @default(0)

    seatCount Int @default(1)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([organizationId])
    @@index([planId])
    @@map("org_subscription")
}

// Org Budget Policy - Organization-level budget controls
model OrgBudgetPolicy {
    id             String       @id @default(cuid())
    organizationId String       @unique
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

    enabled         Boolean @default(false)
    monthlyLimitUsd Float?
    alertAtPct      Float?  @default(80)
    hardLimit       Boolean @default(true)

    defaultUserBudgetUsd Float?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("org_budget_policy")
}

// User Budget Policy - Per-user budget within an organization
model UserBudgetPolicy {
    id             String @id @default(cuid())
    userId         String
    organizationId String

    enabled         Boolean @default(false)
    monthlyLimitUsd Float?
    alertAtPct      Float?  @default(80)
    hardLimit       Boolean @default(true)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([userId, organizationId])
    @@index([userId])
    @@index([organizationId])
    @@map("user_budget_policy")
}

// Platform Markup - Per-model markup rates (admin-managed)
model PlatformMarkup {
    id              String   @id @default(cuid())
    provider        String
    modelName       String
    inputCostPer1M  Float
    outputCostPer1M Float
    defaultMarkup   Float    @default(2.0)
    isActive        Boolean  @default(true)
    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt

    @@unique([provider, modelName])
    @@map("platform_markup")
}

// Budget Alert - Alert history for budget thresholds
model BudgetAlert {
    id              String        @id @default(cuid())
    organizationId  String?
    organization    Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    userId          String?
    agentId         String?
    level           String
    type            String
    percentUsed     Float
    currentSpendUsd Float
    limitUsd        Float
    message         String        @db.Text
    acknowledged    Boolean       @default(false)
    createdAt       DateTime      @default(now())

    @@index([organizationId, createdAt])
    @@index([userId, createdAt])
    @@index([agentId, createdAt])
    @@map("budget_alert")
}

// Unified Change Log for auditable history across agents, workflows, networks
model ChangeLog {
    id         String   @id @default(cuid())
    entityType String // "agent", "workflow", "network"
    entityId   String
    entitySlug String?
    version    Int
    action     String // "create", "update", "rollback", "delete"
    changes    Json // Structured array of field-level diffs
    summary    String?  @db.Text
    reason     String?  @db.Text
    createdBy  String?
    createdAt  DateTime @default(now())

    @@index([entityType, entityId])
    @@index([entityId, version])
    @@index([createdAt])
    @@map("change_log")
}
